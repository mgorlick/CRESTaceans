<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><title>16&nbsp;Persistent ordered trie</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="racket.css" title="default" /><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default" /><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">COAST Library</a></td></tr></table></div><div class="tocviewsublistonly" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="type-testing.html" class="tocviewlink" data-pltdoc="x">Type testing</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="type-transformations.html" class="tocviewlink" data-pltdoc="x">Type transformations</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="equivalence-predicates.html" class="tocviewlink" data-pltdoc="x">Equivalence predicates</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="list-manipulation.html" class="tocviewlink" data-pltdoc="x">List manipulation</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="logical-negation.html" class="tocviewlink" data-pltdoc="x">Logical negation</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="arithmetic-operations.html" class="tocviewlink" data-pltdoc="x">Arithmetic operations</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="numeric-comparisons.html" class="tocviewlink" data-pltdoc="x">Numeric comparisons</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="trigonometric-functions.html" class="tocviewlink" data-pltdoc="x">Trigonometric functions</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="characters.html" class="tocviewlink" data-pltdoc="x">Characters</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="strings.html" class="tocviewlink" data-pltdoc="x">Strings</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="byte-strings.html" class="tocviewlink" data-pltdoc="x">Byte strings</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="persistent-vectors.html" class="tocviewlink" data-pltdoc="x">Persistent functional vectors</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="persistent-hash-tables.html" class="tocviewlink" data-pltdoc="x">Persistent functional hash tables</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="persistent-records.html" class="tocviewlink" data-pltdoc="x">Persistent functional records</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="persistent-sets.html" class="tocviewlink" data-pltdoc="x">Persistent unordered sets</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Persistent ordered trie</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="persistent-tuples.html" class="tocviewlink" data-pltdoc="x">Persistent tuples</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="persistent-binding-environments.html" class="tocviewlink" data-pltdoc="x">Persistent binding environments</a></td></tr><tr><td align="right">19&nbsp;</td><td><a href="islands.html" class="tocviewlink" data-pltdoc="x">Islands</a></td></tr><tr><td align="right">20&nbsp;</td><td><a href="actors.html" class="tocviewlink" data-pltdoc="x">Actors</a></td></tr><tr><td align="right">21&nbsp;</td><td><a href="locatives.html" class="tocviewlink" data-pltdoc="x">Locatives</a></td></tr><tr><td align="right">22&nbsp;</td><td><a href="curls.html" class="tocviewlink" data-pltdoc="x">Capability URL (CURL)</a></td></tr><tr><td align="right">23&nbsp;</td><td><a href="delivery.html" class="tocviewlink" data-pltdoc="x">Delivery</a></td></tr><tr><td align="right">24&nbsp;</td><td><a href="promise.html" class="tocviewlink" data-pltdoc="x">Promise</a></td></tr><tr><td align="right">25&nbsp;</td><td><a href="framework.html" class="tocviewlink" data-pltdoc="x">ISLAND -<wbr></wbr> Peering infrastructure</a></td></tr><tr><td align="right">26&nbsp;</td><td><a href="generate-baseline.html" class="tocviewlink" data-pltdoc="x">BASELINE</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft">&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="persistent-sets.html" title="backward to &quot;15 Persistent unordered sets&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;COAST Library&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="persistent-tuples.html" title="forward to &quot;17 Persistent tuples&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>16<tt>&nbsp;</tt><a name="(part._persistent-trie)"></a>Persistent ordered trie</h3><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktSym">trie/empty</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Produces an empty trie node with a map of zero and no allocated slots.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/car</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">pair?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Assuming that trie node <span class="RktVar">t</span> is non-empty, return the first key/value pair found in a left-to-right depth-first search of the trie rooted at <span class="RktVar">t</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/cdr</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Assuming that trie node <span class="RktVar">t</span> is non-empty, non-destructively return a replacement trie node <span class="RktSym">|t'|</span> such that <span class="RktSym">|t'|</span> is the root of a trie constituting the "rest" of <span class="RktVar">t</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/get</span><span class="hspace">&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span><span class="RktVar">shift</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">pair?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">shift</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">byte?</span></td></tr></table></blockquote></div><div class="SIntrapara">Locate key/value pair in trie node <span class="RktVar">t</span> of hash table <span class="RktSym">h</span>. If found return the pair <span class="RktPn">(</span><span class="RktVar">key</span><span class="stt"> </span><span class="RktPn">. </span><span class="RktSym">value</span><span class="RktPn">)</span>, otherwise return <span class="RktVal">#f</span>. <span class="RktSym">equality</span> is the equality predicate for keys; <span class="RktSym">hash</span> is the hash code of key, that is, return value of <span class="RktPn">(</span><span class="RktSym">hasher</span><span class="stt"> </span><span class="RktSym">key</span><span class="RktPn">)</span>; and <span class="RktSym">shift</span> the rightward shift to compute trie map mask.}</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/with</span><span class="hspace">&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span><span class="RktVar">hasher</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span><span class="RktVar">h</span><span class="hspace">&nbsp;</span><span class="RktVar">shift</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hasher</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">h</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">shift</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">byte?</span></td></tr></table></blockquote></div><div class="SIntrapara">Non-destructively add the key/value pair to trie node t returning the successor trie. <span class="RktVar">equality</span> is the equality predicate for keys; <span class="RktVar">hasher</span> is the hash function for keys; <span class="RktSym">hash</span> is the hash code of key, that is, return value of <span class="RktPn">(</span><span class="RktVar">hasher</span><span class="stt"> </span><span class="RktVar">key</span><span class="RktPn">)</span>; and <span class="RktVar">shift</span> the rightward shift to compute trie map mask.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" class="prototype RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym">trie/key/with</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">equality</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">hasher</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">t</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">key</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">value</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">hash</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">shift</span><span class="RktPn">)</span></td><td><span class="hspace">&nbsp;</span></td><td>&rarr;</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym">trie?</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hasher</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">shift</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">byte?</span></td></tr></table></blockquote></div><div class="SIntrapara">A specialized version of trie/with for the case in which only the key is significant and the accompanying value is immaterial, for example, when using hash tables to implement unordered sets. This allows us to optimize the special case in which the key already appears in trie t or its subnodes by eliminating the expense of generating a new trie or overflow node needlessly. <span class="RktVar">equality</span> is the equality predicate for keys; <span class="RktVar">hasher</span> is the hash function for keys; <span class="RktVar">hash</span> is the hash code of key, that is, return value of <span class="RktPn">(</span><span class="RktVar">hasher</span><span class="stt"> </span><span class="RktVar">key</span><span class="RktPn">)</span>; and <span class="RktVar">shift</span> the rightward shift to compute trie map mask.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/without</span><span class="hspace">&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span><span class="RktVar">shift</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">shift</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">byte?</span></td></tr></table></blockquote></div><div class="SIntrapara">Remove (non-destructively) the given key from the trie whose root is <span class="RktVar">t</span>. <span class="RktVar">equality</span> is the equality predicate for keys; <span class="RktVar">hash</span> is the hash code of key, that is, return value of <span class="RktPn">(</span><span class="RktSym">hasher</span><span class="stt"> </span><span class="RktVar">key</span><span class="RktPn">)</span>; and <span class="RktVar">shift</span> the rightward shift to compute trie map mask.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/pairs/total</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">integer?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Return the total number of trie pairs in the trie rooted at <span class="RktVar">t</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/fold</span><span class="hspace">&nbsp;</span><span class="RktVar">proc</span><span class="hspace">&nbsp;</span><span class="RktVar">seed</span><span class="hspace">&nbsp;</span><span class="RktVar">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">integer?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">proc</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">seed</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">x</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Fold function <span class="RktVar">proc</span> with <span class="RktVar">seed</span> over all trie/pairs appearing in the trie rooted at <span class="RktSym">t</span>. <span class="RktVar">proc</span> accepts two arguments: a <span class="RktSym">trie/pair</span> and the most recent folded value.
;; The first invocation of f is given the seed as the initial folded value.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/flat/fold</span><span class="hspace">&nbsp;</span><span class="RktVar">proc</span><span class="hspace">&nbsp;</span><span class="RktVar">seed</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">integer?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">proc</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">seed</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Similar to <span class="RktSym">trie/pairs/fold</span> above except that <span class="RktVar">proc</span> is given three arguments: key, value, and the most recent folded value. This function helps to insulate higher-level structures such as hash maps and binding environments from the internal representation that the trie uses for key/value pairs.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/for-each</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span><span class="RktVar">proc</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">proc</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr></table></blockquote></div><div class="SIntrapara">Apply function <span class="RktVar">proc</span>, as <span class="RktPn">(</span><span class="RktVar">proc</span><span class="stt"> </span><span class="RktSym">key</span><span class="stt"> </span><span class="RktSym">value</span><span class="RktPn">)</span>, to each key/value in the trie <span class="RktVar">t</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/sort/insertion</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Return the contents of the hash table rooted at <span class="RktVar">t</span> as a list of trie/pair where the list is sorted in increasing insertion order of the pairs.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/sort/insertion=&gt;vector</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">vector?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Like <span class="RktSym">trie/sort/insertion</span> but returns the contents in insertion order as a flat vector <span class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">k_1</span><span class="stt"> </span><span class="RktVal">v_1</span><span class="stt"> </span><span class="RktVal">...</span><span class="stt"> </span><span class="RktVal">k_n</span><span class="stt"> </span><span class="RktVal">v_n</span><span class="RktVal">)</span> where pair <span class="RktSym">k_i/v_i</span> was added to the trie before pair <span class="RktSym">k_</span><span class="stt"> </span><span class="RktPn">{</span><span class="RktSym">i+1</span><span class="RktPn">}</span><span class="stt"> </span><span class="RktSym">/v_</span><span class="stt"> </span><span class="RktPn">{</span><span class="RktSym">i+1</span><span class="RktPn">}</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/pair?</span><span class="hspace">&nbsp;</span><span class="RktVar">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">boolean?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">v</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns <span class="RktVal">#t</span> if <span class="RktVar">v</span> is a trie/pair, and <span class="RktVal">#f</span> otherwise. A trie/pair is a structure that has a key and a value and an associated order.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/pair-order</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">integer?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns the order assigned to a trie/pair.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/pair-key</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns the key of a trie/pair structure.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/pair-value</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie/pair?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns the value of a trie/pair structure.</div></p><div class="navsetbottom"><span class="navleft">&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="persistent-sets.html" title="backward to &quot;15 Persistent unordered sets&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;COAST Library&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="persistent-tuples.html" title="forward to &quot;17 Persistent tuples&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>