<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>16&nbsp;Persistent trie</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="racket.css" title="default" /><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default" /><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" pltdoc="x">COAST Library</a></td></tr></table></div><div class="tocviewsublistonly" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="type-testing.html" class="tocviewlink" pltdoc="x">Type testing</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="type-transformations.html" class="tocviewlink" pltdoc="x">Type transformations</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="equivalence-predicates.html" class="tocviewlink" pltdoc="x">Equivalence predicates</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="list-manipulation.html" class="tocviewlink" pltdoc="x">List manipulation</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="logical-negation.html" class="tocviewlink" pltdoc="x">Logical negation</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="arithmetic-operations.html" class="tocviewlink" pltdoc="x">Arithmetic operations</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="numeric-comparisons.html" class="tocviewlink" pltdoc="x">Numeric comparisons</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="trigonometric-functions.html" class="tocviewlink" pltdoc="x">Trigonometric functions</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="characters.html" class="tocviewlink" pltdoc="x">Characters</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="strings.html" class="tocviewlink" pltdoc="x">Strings</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="byte-strings.html" class="tocviewlink" pltdoc="x">Byte strings</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="persistent-vectors.html" class="tocviewlink" pltdoc="x">Persistent functional vectors</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="persistent-hash-tables.html" class="tocviewlink" pltdoc="x">Persistent functional hash tables</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="persistent-records.html" class="tocviewlink" pltdoc="x">Persistent functional records</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="persistent-sets.html" class="tocviewlink" pltdoc="x">Persistent unordered sets</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Persistent trie</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="persistent-tuples.html" class="tocviewlink" pltdoc="x">Persistent tuples</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="persistent-binding-environments.html" class="tocviewlink" pltdoc="x">Persistent binding environments</a></td></tr><tr><td align="right">19&nbsp;</td><td><a href="islands.html" class="tocviewlink" pltdoc="x">Islands</a></td></tr><tr><td align="right">20&nbsp;</td><td><a href="actors.html" class="tocviewlink" pltdoc="x">Actors</a></td></tr><tr><td align="right">21&nbsp;</td><td><a href="locatives.html" class="tocviewlink" pltdoc="x">Locatives</a></td></tr><tr><td align="right">22&nbsp;</td><td><a href="curls.html" class="tocviewlink" pltdoc="x">Capability URL (CURL)</a></td></tr><tr><td align="right">23&nbsp;</td><td><a href="delivery.html" class="tocviewlink" pltdoc="x">Delivery</a></td></tr><tr><td align="right">24&nbsp;</td><td><a href="promise.html" class="tocviewlink" pltdoc="x">Promise</a></td></tr><tr><td align="right">25&nbsp;</td><td><a href="framework.html" class="tocviewlink" pltdoc="x">ISLAND -<wbr></wbr> Peering infrastructure</a></td></tr><tr><td align="right">26&nbsp;</td><td><a href="generate-baseline.html" class="tocviewlink" pltdoc="x">BASELINE</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft">&nbsp;&nbsp;</span><span class="navright"><a href="persistent-sets.html" title="backward to &quot;15 Persistent unordered sets&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;COAST Library&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="persistent-tuples.html" title="forward to &quot;17 Persistent tuples&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>16<tt>&nbsp;</tt><a name="(part._persistent-trie)"></a>Persistent trie</h3><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktSym">trie/empty</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Produces an empty trie node with a map of zero and no allocated slots.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie?</span><span class="hspace">&nbsp;</span><span class="RktVar">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">boolean?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">v</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns <span class="RktVal">#t</span> if <span class="RktVar">v</span> is a persistent trie, <span class="RktVal">#f</span> otherwise.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/empty?</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">boolean?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns <span class="RktVal">#t</span> if trie <span class="RktVar">t</span> is empty, <span class="RktVal">#f</span> otherwise.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/car</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">pair?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></td></tr></table></blockquote></div><div class="SIntrapara">Assuming that trie node <span class="RktVar">t</span> is non-empty, return the first key/value pair found in a left-to-right depth-first search of the trie rooted at <span class="RktVar">t</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/cdr</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></td></tr></table></blockquote></div><div class="SIntrapara">Assuming that trie node <span class="RktVar">t</span> is non-empty, non-destructively return a replacement trie node <span class="RktSym">|t'|</span> such that <span class="RktSym">|t'|</span> is the root of a trie constituting the "rest" of <span class="RktVar">t</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/get</span><span class="hspace">&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span><span class="RktVar">shift</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">pair?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">shift</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">byte?</span></td></tr></table></blockquote></div><div class="SIntrapara">Locate key/value pair in trie node <span class="RktVar">t</span> of hash table <span class="RktSym">h</span>. If found return the pair <span class="RktPn">(</span><span class="RktVar">key</span><span class="stt"> </span><span class="RktPn">. </span><span class="RktSym">value</span><span class="RktPn">)</span>, otherwise return <span class="RktVal">#f</span>. <span class="RktSym">equality</span> is the equality predicate for keys; <span class="RktSym">hash</span> is the hash code of key, that is, return value of <span class="RktPn">(</span><span class="RktSym">hasher</span><span class="stt"> </span><span class="RktSym">key</span><span class="RktPn">)</span>; and <span class="RktSym">shift</span> the rightward shift to compute trie map mask.}</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/with</span><span class="hspace">&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span><span class="RktVar">hasher</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span><span class="RktVar">h</span><span class="hspace">&nbsp;</span><span class="RktVar">shift</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hasher</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">h</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">shift</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">byte?</span></td></tr></table></blockquote></div><div class="SIntrapara">Non-destructively add the key/value pair to trie node t returning the successor trie. <span class="RktVar">equality</span> is the equality predicate for keys; <span class="RktVar">hasher</span> is the hash function for keys; <span class="RktSym">hash</span> is the hash code of key, that is, return value of <span class="RktPn">(</span><span class="RktVar">hasher</span><span class="stt"> </span><span class="RktVar">key</span><span class="RktPn">)</span>; and <span class="RktVar">shift</span> the rightward shift to compute trie map mask.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" class="prototype RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym">trie/key/with</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">equality</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">hasher</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">t</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">key</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">value</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">hash</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktVar">shift</span><span class="RktPn">)</span></td><td><span class="hspace">&nbsp;</span></td><td>&rarr;</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym">trie?</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hasher</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">shift</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">byte?</span></td></tr></table></blockquote></div><div class="SIntrapara">A specialized version of trie/with for the case in which only the key is significant and the accompanying value is immaterial, for example, when using hash tables to implement unordered sets. This allows us to optimize the special case in which the key already appears in trie t or its subnodes by eliminating the expense of generating a new trie or overflow node needlessly. <span class="RktVar">equality</span> is the equality predicate for keys; <span class="RktVar">hasher</span> is the hash function for keys; <span class="RktVar">hash</span> is the hash code of key, that is, return value of <span class="RktPn">(</span><span class="RktVar">hasher</span><span class="stt"> </span><span class="RktVar">key</span><span class="RktPn">)</span>; and <span class="RktVar">shift</span> the rightward shift to compute trie map mask.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">trie/without</span><span class="hspace">&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span><span class="RktVar">shift</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">equality</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">shift</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">byte?</span></td></tr></table></blockquote></div><div class="SIntrapara">Remove (non-destructively) the given key from the trie whose root is <span class="RktVar">t</span>. <span class="RktVar">equality</span> is the equality predicate for keys; <span class="RktVar">hash</span> is the hash code of key, that is, return value of <span class="RktPn">(</span><span class="RktSym">hasher</span><span class="stt"> </span><span class="RktVar">key</span><span class="RktPn">)</span>; and <span class="RktVar">shift</span> the rightward shift to compute trie map mask.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">pairs/count</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">integer?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></td></tr></table></blockquote></div><div class="SIntrapara">Return the total number of key/value pairs in the trie rooted at <span class="RktVar">t</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym">pairs/fold</span><span class="hspace">&nbsp;</span><span class="RktVar">f</span><span class="hspace">&nbsp;</span><span class="RktVar">seed</span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">integer?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">f</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">seed</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">any/c</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">trie?</span></td></tr></table></blockquote></div><div class="SIntrapara">Fold function <span class="RktVar">f</span> with <span class="RktVar">seed</span> over all pairs appearing in the trie rooted at <span class="RktVar">t</span>.</div></p><div class="navsetbottom"><span class="navleft">&nbsp;&nbsp;</span><span class="navright"><a href="persistent-sets.html" title="backward to &quot;15 Persistent unordered sets&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;COAST Library&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="persistent-tuples.html" title="forward to &quot;17 Persistent tuples&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>