<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>Vortex Library, BEEP Core implementation, RFC 3080 / RFC 3081, XML-RPC, XML-RPC over BEEP, RFC 3529, BEEP Framework, BEEP protocol, BEEP, BEEP library, BEEP libraries, beepcore (Servidores Linux http://www.aspl.es)</title>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-123192-2";
urchinTracker();
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="vortex.css" rel="stylesheet" type="text/css">
</head>
  <body>
    <div class="af-arch-header">
     <img src="main-page-logo.png" > <a href="http://www.aspl.es"><img class="aspl-logo-header" src="aspl-logo-header.png"></a>
    </div>
    <div class="ads">
    <iframe src="http://www.aspl.es/web-ads/index.php?hcolor=fdff4f&amp;fsize=10&amp;bg=555753&amp;fg=ffffff&amp;width=800&amp;height=90" scrolling="no" frameborder="0"></iframe> 
    </div>
    <div class="separator">
    </div>
<div class="thepage">

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="programming_with_xml_rpc">Vortex XML-RPC programming manual (C API) </a></h1><h2><a class="anchor" id="intro">
Introduction</a></h2>
<p>This manual shows how to use the XML-RPC invocation interface built of top Vortex Library. The implementation is based on the experimental protocol defined at RFC3529. This manual assumes you are already familiar with the Vortex API. If you don't, you can check <a class="el" href="starting__to__program.html">this tutorial</a> as a starting point.</p>
<p>On this manual you'll find the following sections:</p>
<p><b>Section 1: </b> An introduction to RPC systems</p>
<ul>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_background">Some concepts and background before starting</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#explaining_a_bit_interfaces">The Raw invocation, The High level invocation and the protocol compiler</a></li>
</ul>
<p><b>Section 2: </b> Using Vortex Library XML-RPC</p>
<ul>
<li><a class="el" href="programming__with__xml__rpc.html#raw_client_invocation">Using the Raw API invocation</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#raw_client_invoke">Performing a client invocation</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#raw_client_invoke_considerations">Raw client invocation considerations</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#receiving_an_invocation">Processing an incoming XML-RPC invocation</a></li>
</ul>
<p><b>Section 3: </b> Using Vortex Library <b>xml-rpc-gen</b> tool</p>
<ul>
<li><a class="el" href="programming__with__xml__rpc.html#abstraction_required">Abstraction required: The xml-rpc-gen tool</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_language">Using xml-rpc-gen tool: language syntax</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_language_types">Types supported by xml-rpc-gen tool</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_language_recursive">Recursive declarations with Struct</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_language_considerations">Considerations while using composing types: Struct and Arrays.</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_language_array_declaration">Array declaration</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_language_no_parameters">Services without parameters</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_language_boolean">Services using and returning boolean types</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_language_double">Services using and returning double types</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_changing_method_name">Changing the method name for a service declared</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_using_resources">Using resources to group your services</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_enforce_resources">Enforcing resources to be used at the IDL</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_including_body_code">Including additional code to be placed at the service module file</a></li>
</ul>
<p><b>Section 4: </b> Using the output produced</p>
<ul>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_using_output_client">Using the output produced by xml-rpc-gen tool at the CLIENT SIDE</a></li>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_using_output_listener">Using the output produced by xml-rpc-gen tool at the LISTENER SIDE</a></li>
</ul>
<p><b>Section 5: </b> Additional topics</p>
<ul>
<li><a class="el" href="programming__with__xml__rpc.html#xml_rpc_authentication_and_security">XML-RPC authentication and Security</a></li>
</ul>
<h2><a class="anchor" id="xml_rpc_background">
Some concepts and background before starting</a></h2>
<p>If you are familiar with RPC environments such CORBA, Web services, Sun RPC or Af-Arch, you can safely skip this section. If you didn't use any kind of RPC software, you should read this section to get valuable information that will help you to not only understand XML-RPC.</p>
<p>All RPC environments are based on a basic concept: to be able to cross the process boundary to execute a method/service/procedure hosted by other process that is reachable through a decoupled link. This decoupled link could be a loopback connection or a network connection to a remote station.</p>
<p>In fact, RPC stands for Remote Produce Call. There are several types of RPC environments, but all of them are characterized by its encapsulation format and its invocation model. While the first characterization is based on textual or binary encapsulation format, the second one is based on environments that execute method inside remote objects or services/procedures hosted by a remote process.</p>
<p>XML-RPC is service-invocation based, using textual encapsulation format, that is, XML. For the case of CORBA, it is method-invocation based, using binary format (its GIOP and IIOP).</p>
<p>Method-invocation environments requires a reference to the remote object that will receive the method invocation. This is not required for service-invocation environments. They just execute the service/produce exposed by the remote object.</p>
<p>All of these environments provide an infrastructure to locate the server that are actually exposing services/methods/procedures to be invoked. However, RPC developers usually fall into providing a host and a port (TCP/IP) to locate the resource, bypassing the location facilities.</p>
<p>The software that provides location services is usually called the binder. For the case of XML-RPC, there is no binder. So, you have to provide all information required to locate your component that will accept to process the service invocation received.</p>
<p>Obviously, in most cases, this isn't a problem, because most of system network design is based on a client/server interaction, making only necessary to know where is located the server component.</p>
<p>Usually, these RPC environments provides two API (or way to use the framework) that could be classified as: Raw invocation interfaces and High level invocation interfaces.</p>
<p>As you may guessing, there are more fun (and pain!) while using the Raw invocation interface than the High level one. Both offers (dis)advantages and both provides a specific functionality, that is required in particular situations.</p>
<h2><a class="anchor" id="explaining_a_bit_interfaces">
The Raw invocation, The High level invocation and the protocol compiler</a></h2>
<p>In general term, the Raw invocation interface provides an API to produce a invocation, defining all the details, while the High level invocation interface is built on top of the Raw interface, and it is usually produced by a protocol compiler tool. This tools is usually called the Interface Definition Language compiler, or just IDL compiler.</p>
<p>This protocol compiler reads a service definition description (every RPC platform has its own version about this language), and produces two products: the client stub and the server skeleton.</p>
<p>The client stub is a small library that exposes the services as they were local functions. Inside these local functions are implemented all the voodoo, using the Raw interface, to actually produce the invocation.</p>
<p>This is great because this client stub component makes the invocation to be really easy, like you were interfacing with local function, making you to forget you are actually calling to a remote object.</p>
<p>The server stub component is the piece of software provided to enable the programmer to actually implement the method to be invoked. It is called skeleton because it is a server with all method/procedures/services without being implemented.</p>
<p>In most cases, RPC developers just don't want to hear about the Raw invocation interface, they use the IDL compiler.</p>
<h2><a class="anchor" id="raw_client_invocation">
Using the Raw API invocation</a></h2>
<p>XML-RPC Raw interface, inside Vortex, is composed by the <a class="el" href="group__vortex__xml__rpc__types.html">XML-RPC type API</a> and the <a class="el" href="group__vortex__xml__rpc.html">invocation interface API</a>.</p>
<p>The first one exposes all types and enum values that are used across all XML-RPC API. The second one is the API that actually do the useful work.</p>
<p>There are two high level type definitions, <a class="el" href="group__vortex__xml__rpc__types_ga9a8681c7f146e5a94f9745739e4806cb.html#ga9a8681c7f146e5a94f9745739e4806cb">XmlRpcMethodCall</a> and <a class="el" href="group__vortex__xml__rpc__types_gaed50561e9b2028aaca8e74c54e2c5bbb.html#gaed50561e9b2028aaca8e74c54e2c5bbb">XmlRpcMethodResponse</a> that, as their names shows, represents the method call object and the method response.</p>
<p>The idea is that you use the <a class="el" href="group__vortex__xml__rpc__types.html">XML-RPC type API</a> to create the <a class="el" href="group__vortex__xml__rpc__types_ga9a8681c7f146e5a94f9745739e4806cb.html#ga9a8681c7f146e5a94f9745739e4806cb">XmlRpcMethodCall</a>, that represents your method at the remote side to be executed, and then, using the invocation interface, you actually produce a service invocation.</p>
<h2><a class="anchor" id="raw_client_invoke">
Performing a client invocation</a></h2>
<p>Let's assume we are going to invoke a simple method, called <b>sum</b>, which receives integer 2 arguments, <b>a</b> and <b>b</b> and return an integer, as a result of adding <b>a</b> to <b>b</b>. What we need is to produce a representation of our method so we can use it to actually produce an invocation. Here is an example on how it could be done:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// declare our method call reference</span>
 <a class="code" href="group__vortex__xml__rpc__types_ga9a8681c7f146e5a94f9745739e4806cb.html#ga9a8681c7f146e5a94f9745739e4806cb" title="Represents an abstraction of a remote procedure invocation.">XmlRpcMethodCall</a>  * invocator;
 <a class="code" href="group__vortex__xml__rpc__types_ga7a737b4957d15112f74750bfa95bd2be.html#ga7a737b4957d15112f74750bfa95bd2be" title="Abstraction of a value stored inside a method call or a method response.">XmlRpcMethodValue</a> * value;

 <span class="comment">// create the method call, called sum, with 2 arguments</span>
 invocator = <a class="code" href="group__vortex__xml__rpc__types_ga84fbc809c8fc2a518657da337e0e88d2.html#ga84fbc809c8fc2a518657da337e0e88d2" title="Creates a new method call object, representing a remote procedure invocation.">vortex_xml_rpc_method_call_new</a> (<span class="stringliteral">&quot;sum&quot;</span>, 2);

 <span class="comment">// now create method parameters </span>
 value = <a class="code" href="group__vortex__xml__rpc__types_ga1e63289d1b856a74458ce9023efc980a.html#ga1e63289d1b856a74458ce9023efc980a" title="Allows to create a new XmlRpcMethodValue object from the given type and the given...">vortex_xml_rpc_method_value_new</a> (<a class="code" href="group__vortex__xml__rpc__types_gaa29cfe7b792cedbe00f70786a4d5e9f1.html#ggaa29cfe7b792cedbe00f70786a4d5e9f1a3233e7b7a146519e3331c60d0fc62fc3" title="Represents a int value, four bype signed integer.">XML_RPC_INT_VALUE</a>, 
                                          PTR_TO_INT(2));

 <span class="comment">// add the method value to the invocator object</span>
 <a class="code" href="group__vortex__xml__rpc__types_ga2c4484e04a9a450088feab6318df3b66.html#ga2c4484e04a9a450088feab6318df3b66" title="Allows to add the given XmlRpcMethodValue in the next parameter position available...">vortex_xml_rpc_method_call_add_value</a> (invocator, value);

 <span class="comment">// create the other method parameter </span>
 value = <a class="code" href="group__vortex__xml__rpc__types_ga1e63289d1b856a74458ce9023efc980a.html#ga1e63289d1b856a74458ce9023efc980a" title="Allows to create a new XmlRpcMethodValue object from the given type and the given...">vortex_xml_rpc_method_value_new</a> (<a class="code" href="group__vortex__xml__rpc__types_gaa29cfe7b792cedbe00f70786a4d5e9f1.html#ggaa29cfe7b792cedbe00f70786a4d5e9f1a3233e7b7a146519e3331c60d0fc62fc3" title="Represents a int value, four bype signed integer.">XML_RPC_INT_VALUE</a>,
                                          PTR_TO_INT(3));

 <span class="comment">// add the method value to the invocator object</span>
 <a class="code" href="group__vortex__xml__rpc__types_ga2c4484e04a9a450088feab6318df3b66.html#ga2c4484e04a9a450088feab6318df3b66" title="Allows to add the given XmlRpcMethodValue in the next parameter position available...">vortex_xml_rpc_method_call_add_value</a> (invocator, value);
</pre></div><p>Now we have a representation of our method call. What we need now, is to use this it to produce an invocation. This is done by first creating a connection to the remote server, booting a XML-RPC channel. Here is an example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// a method response declaration</span>
 <a class="code" href="group__vortex__xml__rpc__types_gaed50561e9b2028aaca8e74c54e2c5bbb.html#gaed50561e9b2028aaca8e74c54e2c5bbb" title="Abstraction to represent a method response object.">XmlRpcMethodResponse</a> * response;

 <span class="comment">// a vortex connection to the remote peer</span>
 <a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection;

 <span class="comment">// a channel referece to the remote peer</span>
 <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a>    * channel;

 <span class="comment">// some variables to get textual status</span>
 <a class="code" href="group__vortex__types_ga25d85d2d28e8808a03b003e13c452e17.html#ga25d85d2d28e8808a03b003e13c452e17" title="Vortex Operation Status.">VortexStatus</a>       status;
 <span class="keywordtype">char</span>             * message;

 <span class="comment">// the ctx variable represents a context already initialized with</span>
 <span class="comment">// vortex_ctx_new followed by vortex_init_ctx</span>

 <span class="comment">// call to enable XML-RPC on the context </span>
 <span class="keywordflow">if</span> (! <a class="code" href="group__vortex__xml__rpc_ga5060db23d0539d4a39024e0e0c024a3c.html#ga5060db23d0539d4a39024e0e0c024a3c" title="Inits the vortex xml-rpc module state.">vortex_xml_rpc_init</a> (ctx)) {
     printf (<span class="stringliteral">&quot;Unable to init XML-RPC support..\n&quot;</span>);
     <span class="keywordflow">return</span>;
 }

 <span class="comment">// create the connection to a known location (in a blocking manner for</span>
 <span class="comment">// demostration purposes)</span>
 connection = <a class="code" href="group__vortex__connection_ga727b938695d1037058256e3559d9d599.html#ga727b938695d1037058256e3559d9d599" title="Allows to create a new BEEP session (connection) to the given host:port.">vortex_connection_new</a> (ctx, <span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;22000&quot;</span>, NULL, NULL);

 <span class="comment">// boot an XML-RPC channel</span>
 channel = <a class="code" href="group__vortex__xml__rpc_gaa2040e191f21955507699049341ee15c.html#gaa2040e191f21955507699049341ee15c" title="Perform a synchronous (blocking) XML-RPC channel boot.">vortex_xml_rpc_boot_channel_sync</a> (connection, NULL, NULL, &amp;status, &amp;message);

 <span class="comment">// show message returned </span>
 <span class="keywordflow">if</span> (status == <a class="code" href="group__vortex__types_ga25d85d2d28e8808a03b003e13c452e17.html#gga25d85d2d28e8808a03b003e13c452e17af832d5ec80b9b87f8e7d6ef0a5fd3366" title="Represents an Error while Vortex Library was operating.">VortexError</a>) {
      printf (<span class="stringliteral">&quot;Unable to create XML-RPC channel, message was: %s\n&quot;</span>, message);
      <span class="keywordflow">return</span>;
 }<span class="keywordflow">else</span> {
      printf (<span class="stringliteral">&quot;XML-RPC channel created, message was: %s\n&quot;</span>, message);
 }
 
 <span class="comment">// peform a synchronous method </span>
 printf (<span class="stringliteral">&quot;   Performing XML-RPC invocation..\n&quot;</span>);
 response = <a class="code" href="group__vortex__xml__rpc_ga559973d5a56be88f09d3eeb86accd218.html#ga559973d5a56be88f09d3eeb86accd218" title="Perform a synchronous XML-RPC invocation using a method call already built over an...">vortex_xml_rpc_invoke_sync</a> (channel, invocator);

 <span class="keywordflow">switch</span> (<a class="code" href="group__vortex__xml__rpc__types_ga7fab4d0f32074b54e42bf520ef1de677.html#ga7fab4d0f32074b54e42bf520ef1de677" title="Alias definition for vortex_xml_rpc_method_response_get_status.">method_response_get_status</a> (response)) {
 <span class="keywordflow">case</span> <a class="code" href="group__vortex__xml__rpc__types_ga4d776daa7b02e9c49a6633ae00002f6b.html#gga4d776daa7b02e9c49a6633ae00002f6ba0d6381d233a422990b6b5f50d9291570" title="The XmlRpc operation have finished properly.">XML_RPC_OK</a>:
     printf (<span class="stringliteral">&quot;Reply received ok, result is: %s\n&quot;</span>, <a class="code" href="group__vortex__xml__rpc__types_ga90aeab2acb7e58b0712bae372caa6025.html#ga90aeab2acb7e58b0712bae372caa6025" title="Alias definition for vortex_xml_rpc_method_response_stringify.">method_response_stringify</a> (response));
     <span class="keywordflow">break</span>;
 <span class="keywordflow">default</span>:
     printf (<span class="stringliteral">&quot;RPC invocation have failed: (code: %d) : %s\n&quot;</span>,
              <a class="code" href="group__vortex__xml__rpc__types_gadbbfd0e0df59daa348c2bd9af24bd7c1.html#gadbbfd0e0df59daa348c2bd9af24bd7c1" title="Alias definition for vortex_xml_rpc_method_response_get_fault_code.">method_response_get_fault_code</a> (response),
              <a class="code" href="group__vortex__xml__rpc__types_ga12fc220f4a0c2f5ac91ac6c6c886327e.html#ga12fc220f4a0c2f5ac91ac6c6c886327e" title="Alias definition for vortex_xml_rpc_method_response_get_fault_string.">method_response_get_fault_string</a> (response));
     <span class="keywordflow">break</span>;
 }

 <span class="comment">// free the response received </span>
 <a class="code" href="group__vortex__xml__rpc__types_ga2d1e28475fa54a88669de127f11525c2.html#ga2d1e28475fa54a88669de127f11525c2" title="Alias definition for vortex_xml_rpc_method_response_free.">method_response_free</a> (response);

 <span class="comment">// free the method invocator used </span>
 <a class="code" href="group__vortex__xml__rpc__types_gafecfc8461bc3b3b912fcefb19ae9ce19.html#gafecfc8461bc3b3b912fcefb19ae9ce19" title="Alias definition for vortex_xml_rpc_method_call_free.">method_call_free</a> (invocator);
</pre></div><p>Well, it is impressive the huge amount of things to be done to simple invoke a sum operation that is on the remote side, isn't it? That's why people doesn't use Raw interface, preferring to use the High level one while producing common RPC tasks.</p>
<p>However, this interface is required if you need to produce a custom invocator that perform some special task before doing the actual invocation, or just because you need a general invocation software to track down all invocations received, at server side, so you can re-send that invocation to another system, acting as a proxy.</p>
<h2><a class="anchor" id="raw_client_invoke_considerations">
Raw client invocation considerations</a></h2>
<p>Before seeing previous example, here are some issues to be considered:</p>
<ul>
<li>
<p class="startli">To actually produce an invocation, you need an already booted channel (<a class="el" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f">VortexChannel</a>) and an invocator object (<a class="el" href="group__vortex__xml__rpc__types_ga9a8681c7f146e5a94f9745739e4806cb.html#ga9a8681c7f146e5a94f9745739e4806cb">XmlRpcMethodCall</a>). Once initialized they could be used over and over again.</p>
<p>So, you can actually reuse the same channel (<a class="el" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f">VortexChannel</a>) to perform invocations, with some restrictions, explained bellow, without requiring to boot one channel every time.</p>
<p>You can also reuse the <a class="el" href="group__vortex__xml__rpc__types_ga9a8681c7f146e5a94f9745739e4806cb.html#ga9a8681c7f146e5a94f9745739e4806cb">XmlRpcMethodCall</a> to produce an invocation for the same function, without needing to create it over and over again.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>A channel could be reused for any number of invocation, with no restriction. However, you have to know that once an invocation is in progress, that channel couldn't be used again to produce a new independent invocation. If done, the new invocation will be blocked until the previous is finished.</p>
<p>A channel have an invocation in progress if the channel is performing an invocation, activated by a call to <a class="el" href="group__vortex__xml__rpc_gaa6eddcc6c70ee52a5d049c44c3a84c15.html#gaa6eddcc6c70ee52a5d049c44c3a84c15">vortex_xml_rpc_invoke</a> or <a class="el" href="group__vortex__xml__rpc_ga559973d5a56be88f09d3eeb86accd218.html#ga559973d5a56be88f09d3eeb86accd218">vortex_xml_rpc_invoke_sync</a>, and the reply wasn't received yet.</p>
<p>To produce several independent invocations at the same type over the same connection, you have to boot several channels. This method produce good performance results. You can read more about this here: <a class="el" href="starting__to__program.html#vortex_manual_implementing_request_response_pattern">3.2 Implementing the request-response pattern</a>.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Previous example, uses the synchronous invocation method. You should consider using <a class="el" href="group__vortex__xml__rpc_gaa6eddcc6c70ee52a5d049c44c3a84c15.html#gaa6eddcc6c70ee52a5d049c44c3a84c15">vortex_xml_rpc_invoke</a> function to produce a non blocking invocation, to get better results, especially while working with graphical user interfaces. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Previous example stringify the results received (<a class="el" href="group__vortex__xml__rpc__types_gaed50561e9b2028aaca8e74c54e2c5bbb.html#gaed50561e9b2028aaca8e74c54e2c5bbb">XmlRpcMethodResponse</a>) using <a class="el" href="group__vortex__xml__rpc__types_ga307719f28edc42f90ee1b25771f4850a.html#ga307719f28edc42f90ee1b25771f4850a">vortex_xml_rpc_method_response_stringify</a>. This function is great for an example, but, in real life application, if the user application requires and integer, you can't reply a string.</p>
<p>In this context, the usual operation performed on a <a class="el" href="group__vortex__xml__rpc__types_gaed50561e9b2028aaca8e74c54e2c5bbb.html#gaed50561e9b2028aaca8e74c54e2c5bbb">XmlRpcMethodResponse</a> received, is to get the value inside (<a class="el" href="group__vortex__xml__rpc__types_ga7a737b4957d15112f74750bfa95bd2be.html#ga7a737b4957d15112f74750bfa95bd2be">XmlRpcMethodValue</a>) calling to <a class="el" href="group__vortex__xml__rpc__types_ga1c9eb789b0e0e671ba8aa2de34930b26.html#ga1c9eb789b0e0e671ba8aa2de34930b26">vortex_xml_rpc_method_response_get_value</a>.</p>
<p>Then, the next set of functions will help you to get the value marshalled into the appropriate type:</p>
<ul>
<li><a class="el" href="group__vortex__xml__rpc__types_gadcf09bfdb913af4ae341a4f07abe0244.html#gadcf09bfdb913af4ae341a4f07abe0244">vortex_xml_rpc_method_value_get_as_int</a></li>
<li><a class="el" href="group__vortex__xml__rpc__types_ga825610f1eb4489b171014fb2d49caa1b.html#ga825610f1eb4489b171014fb2d49caa1b">vortex_xml_rpc_method_value_get_as_double</a></li>
<li><a class="el" href="group__vortex__xml__rpc__types_gaa62c07a6f2ec3e30ab536321c3356232.html#gaa62c07a6f2ec3e30ab536321c3356232">vortex_xml_rpc_method_value_get_as_string</a></li>
<li><a class="el" href="group__vortex__xml__rpc__types_ga8dd353b17dc0a5a5549ea932e5ab8f2f.html#ga8dd353b17dc0a5a5549ea932e5ab8f2f">vortex_xml_rpc_method_value_get_as_struct</a></li>
<li><a class="el" href="group__vortex__xml__rpc__types_ga60ed01484447a26cb6d5df8ec1b19983.html#ga60ed01484447a26cb6d5df8ec1b19983">vortex_xml_rpc_method_value_get_as_array</a></li>
</ul>
<p>For the case of boolean values, you can use the same function for the int type. boolean values, inside XML-RPC, are modeled using 0 and 1 states to represent axl_true and axl_false. </p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="receiving_an_invocation">
Processing an incoming XML-RPC invocation</a></h2>
<p>We have seen in previous sections how a XML-RPC invocation is produced. Now, it is time to know what happens on the remote side, because, until now, we have just moved the problem from a machine to another. However, the problem remains unresolved.</p>
<p>Listener side implementation is built on top of two handlers: <a class="el" href="group__vortex__xml__rpc_gaa4200cc2dfd02845f16ad819389391ae.html#gaa4200cc2dfd02845f16ad819389391ae">the validation resource handler</a> and the <a class="el" href="group__vortex__xml__rpc_ga430cc7a9c84542ed680883355617bf79.html#ga430cc7a9c84542ed680883355617bf79">the service dispatch handler</a>.</p>
<p>The first is used to provide a way to validate resource context, when a channel boot request is received. According to the RFC3529, a resource could be interpreted in many ways, for example, as a supported interface or as a domain that encloses several services. It could be used also to provide a versioning mechanism for the same service.</p>
<p>So the resource "/version/1.0" and the resource "/version/1.2" could allow to support the same service name, but with different versions.</p>
<p>Let's considered the following XML-RPC uri value to clearly understand the resource concept:</p>
<div class="fragment"><pre class="fragment">   xmlrpc.beep:<span class="comment">//example.server.com/NumberToName</span>
</pre></div><p>Previous XML-RPC uri states that there is a XML-RPC listener server at <b>example.server.com</b> located at the IANA registered port <b>602</b> (because no port was specified by appending to the server name, the value in the form <b>:port-num</b>), and it is required to ask for the resource <b>NumberToName</b> before producing the actual invocation.</p>
<p><b>NumberToName</b> is not the service name. It is just a resource that the XML-RPC listener may reply that it is actually supported or not. In fact, you can still export services without doing anything with resources. Here is an example of a XML-RPC uri used to connect to a particular server at the default resource <b>"/"</b></p>
<div class="fragment"><pre class="fragment">   xmlrpc.beep:<span class="comment">//example.server.com/</span>
</pre></div><p>In this context, the validation resource handler is used to notify the Vortex engine if the listener is willing to accept a particular resource value once a XML-RPC channel is being started. In many cases, you can safely avoid setting the resource handler. This will make Vortex XML-RPC engine to accept all resources requested.</p>
<p>Now, let's talk about the <a class="el" href="group__vortex__xml__rpc_ga430cc7a9c84542ed680883355617bf79.html#ga430cc7a9c84542ed680883355617bf79">service dispatch handler</a>. As it names shows, it is used to enable the Vortex engine to notify user space code that a new method invocation have arrived (<a class="el" href="group__vortex__xml__rpc__types_ga9a8681c7f146e5a94f9745739e4806cb.html#ga9a8681c7f146e5a94f9745739e4806cb">XmlRpcMethodCall</a>) and that it has to be dispatched to the appropriate handler. This handler is mainly provided to allow developers to be able to produce its own service dispatching policy.</p>
<p>Let's see a simple dispatching implementation for the sum service introduced at the <a class="el" href="programming__with__xml__rpc.html#raw_client_invoke">client invocation section</a>. Let's see the example first to later see some considerations:</p>
<p>First, the listener side must active a listener that is willing to accept the XML-RPC profile:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// vortex global context </span>
 <a class="code" href="group__vortex__types_ga879b03a2476b60c5b9b75489aabfe7db.html#ga879b03a2476b60c5b9b75489aabfe7db" title="Vortex library context.">VortexCtx</a> * ctx = NULL;

 <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span>  argc, <span class="keywordtype">char</span>  ** argv) 
 {

      <span class="comment">// create an empty context </span>
      ctx = <a class="code" href="group__vortex__ctx_gada9a1d87bfe28dd117f6d6b4356d6e31.html#gada9a1d87bfe28dd117f6d6b4356d6e31" title="Creates a new vortex execution context.">vortex_ctx_new</a> ();

      <span class="comment">// init the context</span>
      <span class="keywordflow">if</span> (! <a class="code" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280" title="Context based vortex library init.">vortex_init_ctx</a> (ctx)) {
           printf (<span class="stringliteral">&quot;failed to init the library..\n&quot;</span>);
      } 

      <span class="comment">// enable XML-RPC profile </span>
      <a class="code" href="group__vortex__xml__rpc_gac9bf811d07fc42beb4dac8bbb338e6ec.html#gac9bf811d07fc42beb4dac8bbb338e6ec" title="Allow to start receiving incoming XML-RPC request, setting two handlers to validate...">vortex_xml_rpc_accept_negotiation</a> (ctx, validate_resource,
                                         <span class="comment">// no user space data for</span>
                                         <span class="comment">// the validation resource</span>
                                         <span class="comment">// function. </span>
                                         NULL, 
                                         service_dispatch,
                                         <span class="comment">// no user space data for</span>
                                         <span class="comment">// the dispatch function. </span>
                                         NULL);

      <span class="comment">// create a vortex server </span>
      <a class="code" href="group__vortex__listener_ga9745c0a637eb270f60b290efe5193352.html#ga9745c0a637eb270f60b290efe5193352" title="Creates a new Vortex Listener accepting incoming connections on the given host:port...">vortex_listener_new</a> (ctx, <span class="stringliteral">&quot;0.0.0.0&quot;</span>, <span class="stringliteral">&quot;44000&quot;</span>, NULL, NULL);

      <span class="comment">// wait for listeners (until vortex_exit is called) </span>
      <a class="code" href="group__vortex__listener_ga8c905a74e007c89508b3add33e595c53.html#ga8c905a74e007c89508b3add33e595c53" title="Blocks a listener (or listeners) launched until vortex finish.">vortex_listener_wait</a> (ctx);
        
      <span class="comment">// end vortex function </span>
      <a class="code" href="group__vortex_ga755d3c8fb55979c25c5abb1ab3939faa.html#ga755d3c8fb55979c25c5abb1ab3939faa" title="Terminates the vortex library execution on the provided context.">vortex_exit_ctx</a> (ctx, axl_true);

      <span class="keywordflow">return</span> 0;
 }
</pre></div><p>The example is quite simple, first, Vortex Library is initialized, then a call to <a class="el" href="group__vortex__xml__rpc_gac9bf811d07fc42beb4dac8bbb338e6ec.html#gac9bf811d07fc42beb4dac8bbb338e6ec">vortex_xml_rpc_accept_negotiation</a> is done to active the XML-RPC. Then a call to activate a listener, for any host name that the local machine may have, at the port 44000, is done by using <a class="el" href="group__vortex__listener_ga9745c0a637eb270f60b290efe5193352.html#ga9745c0a637eb270f60b290efe5193352">vortex_listener_new</a>. Finally, a call to <a class="el" href="group__vortex__listener_ga8c905a74e007c89508b3add33e595c53.html#ga8c905a74e007c89508b3add33e595c53">vortex_listener_wait</a> is done to ensure the server initialization code is blocked until the server finish.</p>
<p>Here is an example of a validation resource function that only accept some resources names: </p>
<div class="fragment"><pre class="fragment"> axl_bool      validate_resource (<a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection, 
                                  <span class="keywordtype">int</span>                channel_number,
                                  <span class="keywordtype">char</span>             * serverName,
                                  <span class="keywordtype">char</span>             * resource_path)
 {
      <span class="comment">// check that resource received</span>
      <span class="keywordflow">if</span> (axl_cmp (resource_path, <span class="stringliteral">&quot;/aritmetic-services/1.0&quot;</span>))
              <span class="keywordflow">return</span> axl_true;
      <span class="keywordflow">if</span> (axl_cmp (resource_path, <span class="stringliteral">&quot;/aritmetic-services/1.1&quot;</span>))
              <span class="keywordflow">return</span> axl_true;
    
      <span class="comment">// resource not recognized, just return axl_false to signal</span>
      <span class="comment">// vortex engine that the channel must not be accepted.</span>
      <span class="keywordflow">return</span> axl_false;
 }
</pre></div><p>And here is a service dispatch implementation, for our service example <b>sum</b>:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span>  __sum_2_int_int (<span class="keywordtype">int</span>  a, <span class="keywordtype">int</span>  b, <span class="keywordtype">char</span>  ** fault_error, <span class="keywordtype">int</span>  * fault_code)
 {
      <span class="keywordflow">if</span> (a == 2 &amp;&amp; b == 7) {
              <span class="comment">// this is an example on how the return a fault reply that includes</span>
              <span class="comment">// an error code an error string.</span>
                <a class="code" href="group__vortex__xml__rpc__types_ga025c234cbdc66286c3a20ff06bae692f.html#ga025c234cbdc66286c3a20ff06bae692f" title="Perform an error reply inside a XML-RPC server stub implementation.">REPLY_FAULT</a> (<span class="stringliteral">&quot;Current implementation is not allowed to sum the 2 and 7 values&quot;</span>, -1, 0);
      }
        
      <span class="comment">// for the rest of cases, just sum the two incoming values </span>
      <span class="keywordflow">return</span> a + b;
 }


 <a class="code" href="group__vortex__xml__rpc__types_gaed50561e9b2028aaca8e74c54e2c5bbb.html#gaed50561e9b2028aaca8e74c54e2c5bbb" title="Abstraction to represent a method response object.">XmlRpcMethodResponse</a> * sum_2_int_int (<a class="code" href="group__vortex__xml__rpc__types_ga9a8681c7f146e5a94f9745739e4806cb.html#ga9a8681c7f146e5a94f9745739e4806cb" title="Represents an abstraction of a remote procedure invocation.">XmlRpcMethodCall</a> * method_call)
 {

      <span class="keywordtype">int</span>                 result;
      <span class="keywordtype">char</span>              * fault_error = NULL;
      <span class="keywordtype">int</span>                 fault_code  = -1;

      <span class="comment">// get values inside the method call</span>
      <span class="keywordtype">int</span>  a = <a class="code" href="group__vortex__xml__rpc__types_gad1545accac507b2de50717fb49d1e3dd.html#gad1545accac507b2de50717fb49d1e3dd" title="Alias definition for vortex_xml_rpc_method_call_get_param_value_as_int.">method_call_get_param_value_as_int</a> (method_call, 0);
      <span class="keywordtype">int</span>  b = <a class="code" href="group__vortex__xml__rpc__types_gad1545accac507b2de50717fb49d1e3dd.html#gad1545accac507b2de50717fb49d1e3dd" title="Alias definition for vortex_xml_rpc_method_call_get_param_value_as_int.">method_call_get_param_value_as_int</a> (method_call, 1);

      <span class="comment">// perform invocation </span>
      result = __sum_2_int_int (a, b, &amp;fault_error, &amp;fault_code);
        
      <span class="comment">// check error reply looking at the fault_error </span>
      <span class="keywordflow">if</span> (fault_error != NULL) {
          <span class="comment">// we have a error reply </span>
            <span class="keywordflow">return</span> <a class="code" href="group__vortex__xml__rpc__types_gab4b482b9f2e406cfce2777b2e8ec1ddd.html#gab4b482b9f2e406cfce2777b2e8ec1ddd" title="Creates a negative XmlRpcMethodResponse containing the provided fault code and fault...">CREATE_FAULT_REPLY</a> (fault_code, fault_error);
      }

      <span class="comment">// return reply generated </span>
      <span class="keywordflow">return</span> <a class="code" href="group__vortex__xml__rpc__types_ga10b9e39603516634b458410b89d180dd.html#ga10b9e39603516634b458410b89d180dd" title="Helper function to create positive XmlRpcMethodResponse objects by providing a reference...">CREATE_OK_REPLY</a> (<a class="code" href="group__vortex__xml__rpc__types_gaa29cfe7b792cedbe00f70786a4d5e9f1.html#ggaa29cfe7b792cedbe00f70786a4d5e9f1a3233e7b7a146519e3331c60d0fc62fc3" title="Represents a int value, four bype signed integer.">XML_RPC_INT_VALUE</a>, INT_TO_PTR (result));
 }

 <a class="code" href="group__vortex__xml__rpc__types_gaed50561e9b2028aaca8e74c54e2c5bbb.html#gaed50561e9b2028aaca8e74c54e2c5bbb" title="Abstraction to represent a method response object.">XmlRpcMethodResponse</a> *  service_dispatch (<a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a> * channel, <a class="code" href="group__vortex__xml__rpc__types_ga9a8681c7f146e5a94f9745739e4806cb.html#ga9a8681c7f146e5a94f9745739e4806cb" title="Represents an abstraction of a remote procedure invocation.">XmlRpcMethodCall</a> * method_call, axlPointer user_data) 
 {
        

      <span class="comment">// check if the incoming method call is called sum, and has</span>
      <span class="comment">// two arguments </span>
      <span class="keywordflow">if</span> (<a class="code" href="group__vortex__xml__rpc__types_gaa87b23e2d7f9b415e78ec6ccbe2f931e.html#gaa87b23e2d7f9b415e78ec6ccbe2f931e" title="Alias definition for vortex_xml_rpc_method_call_is.">method_call_is</a> (method_call, <span class="stringliteral">&quot;sum&quot;</span>, 2, <a class="code" href="group__vortex__xml__rpc__types_gaa29cfe7b792cedbe00f70786a4d5e9f1.html#ggaa29cfe7b792cedbe00f70786a4d5e9f1a3233e7b7a146519e3331c60d0fc62fc3" title="Represents a int value, four bype signed integer.">XML_RPC_INT_VALUE</a>, <a class="code" href="group__vortex__xml__rpc__types_gaa29cfe7b792cedbe00f70786a4d5e9f1.html#ggaa29cfe7b792cedbe00f70786a4d5e9f1a3233e7b7a146519e3331c60d0fc62fc3" title="Represents a int value, four bype signed integer.">XML_RPC_INT_VALUE</a>, -1)) {
          <span class="keywordflow">return</span> sum_2_int_int (method_call);
      }
               
      <span class="comment">// return that the method to be invoked, is not supported </span>
      <span class="keywordflow">return</span> <a class="code" href="group__vortex__xml__rpc__types_gab4b482b9f2e406cfce2777b2e8ec1ddd.html#gab4b482b9f2e406cfce2777b2e8ec1ddd" title="Creates a negative XmlRpcMethodResponse containing the provided fault code and fault...">CREATE_FAULT_REPLY</a> (-1, <span class="stringliteral">&quot;Method call received couldn&#39;t be dispatched because it not supported by this server&quot;</span>);
 }
</pre></div><p>The example shows how the service dispatch handler is the <b>service_dispatch</b> function, which first recognizes if the service is supported and then call to the appropriate handler.</p>
<p>Here is the first interesting thing, the function <a class="el" href="group__vortex__xml__rpc__types_gaa87b23e2d7f9b415e78ec6ccbe2f931e.html#gaa87b23e2d7f9b415e78ec6ccbe2f931e">method_call_is</a>. It is used to recognize service patterns like name, number of parameter and the parameter type. This allows to easily recognize the service to actually dispatch.</p>
<p>In this function, <b>service_dispatch</b>, should be created a <a class="el" href="group__vortex__xml__rpc__types_gaed50561e9b2028aaca8e74c54e2c5bbb.html#gaed50561e9b2028aaca8e74c54e2c5bbb">XmlRpcMethodResponse</a> to be returned. So, the vortex engine could reply as fast as possible. However, the implementation is prepared to defer the reply. This allows, especially, to communicate with other language runtimes. Once the runtime have generated the reply, it must be used the following function <a class="el" href="group__vortex__xml__rpc_ga88e20e6230c1989419328c08f6b779cb.html#ga88e20e6230c1989419328c08f6b779cb">vortex_xml_rpc_notify_reply</a>, to actually perform the reply.</p>
<h2><a class="anchor" id="abstraction_required">
Abstraction required: The xml-rpc-gen tool</a></h2>
<p>Until now, we have seen that producing RPC enabled solutions is really complex. First, because we have to produce the server implementation, and then, all source code required to actually perform the invocation.</p>
<p>However, every RPC framework comes with a protocol compiler that helps on producing lot of source code. For the XML-RPC over BEEP implementation that comes with Vortex Library, this tool is <b>xml-rpc-gen</b>.</p>
<p>This tool reads IDL and XDL interface definitions and produce a ready server and a client library (usually called <b><em>stub</em></b>) that allows to perform the service invocation without paying attention to XML-RPC invocation details. Let's see an example to introduce the tool:</p>
<div class="fragment"><pre class="fragment"><span class="comment">/* This is a test that invokes a simple service with two integers and</span>
<span class="comment"> * returns its result.</span>
<span class="comment"> */</span>
xml-rpc interface test {
        <span class="comment">/* add two integers */</span>
        <span class="keywordtype">int</span> sum (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {
                <span class="comment">/* sum values received */</span>
                <span class="keywordflow">return</span> a + b;
        }

        <span class="comment">/* empty service definition */</span>
        <span class="keywordtype">int</span> operate (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b);
}
</pre></div><p>Now write previous example (just copy the example) into a file (let's say <b><em>reg-test01.idl</em></b>, you have a copy inside the <b><em>../xml-rpc-gen/</em></b> directory, bundled with the Vortex Library source code) and exec the following:</p>
<div class="fragment"><pre class="fragment"> &gt;&gt; ./xml-rpc-gen reg-test01.idl
 [*] compiling: reg-test01.idl..
 [*] detected IDL format definition..
 [*] detected xml-rpc definition: <span class="stringliteral">&#39;test&#39;</span>..
 [*] document is well-formed: reg-test01.idl..
 [*] document is valid: reg-test01.idl..
 [*] component name: <span class="stringliteral">&#39;test&#39;</span>..
 [*] <span class="keyword">using</span> <span class="stringliteral">&#39;out&#39;</span> as out directory..
 [*] generating client stub at: out/client-test..
 [*] generating server stub at: out/server-test..
 [*] generating autoconf files..
 [*] compilation ok
</pre></div><p>Previous interface definition have produced two components:</p>
<ul>
<li><b>A client stub</b>: a library that have an interface to invoke services, located at: <b><em>out/client-test</em></b></li>
</ul>
<ul>
<li><b>A server component</b>: that implements service exported, located at: <b><em>out/client-test</em></b>.</li>
</ul>
<p>Now, instead of producing all source code required to perform the invocation, the <b>xml-rpc-gen</b> tool allows you define a xml-rpc interface definition, that produces that code for you. In this case, looking at: <b><em>out/client-test/test_xml_rpc.h</em></b>, you'll find a C API that hides all details to actually invoke the <b><em>sum</em></b> service.</p>
<p>In the other hand, instead of producing all source code, at the server side, to unmarshall and invoke the service, all this code is produced by <b>xml-rpc-gen</b> tool. In this case, looking at: <b><em>out/server-test/test_sum_int_int.c</em></b> you'll find the <b>sum</b> service implementation.</p>
<p>In the following sections it is explained how to use the <b>xml-rpc-gen</b> tool to produce RPC solutions.</p>
<h2><a class="anchor" id="xml_rpc_gen_tool_language">
Using xml-rpc-gen tool: language syntax</a></h2>
<p><b>xml-rpc-gen</b> is a compiler that produces a client component and a server component. The client component is just a library that hides all details required to perform the invocation. The tool support two formats: one structured, more based on the IDL (Interface Definition Language) language found in other platforms, and a XML based format, called XDL (XML Definition Language).</p>
<p>Internally, the tool is programmed on top of XDL definition language. If the tool detects that the input file is written using the IDL format, it translate that representation into an equivalent XDL representation, starting the processing as the input were XDL. In any case, both language representations are equivalent and well supported.</p>
<p>The interface definition is composed by the global interface declaration and, at least, one service definition. Here is an example using both formats:</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* This is a test that invokes a simple service with two integers and</span>
<span class="comment"> * returns its result.</span>
<span class="comment"> */</span>
xml-rpc interface test {
        <span class="comment">/* add two integers */</span>
        <span class="keywordtype">int</span> sum (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {
                <span class="comment">/* sum values received */</span>
                <span class="keywordflow">return</span> a + b;
        }

        <span class="comment">/* empty service definition */</span>
        <span class="keywordtype">int</span> operate (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b);
}
</pre></div><p><b>XDL format:</b> </p>
<div class="fragment"><pre class="fragment">&lt;xml-rpc-interface&gt;
  &lt;!-- component name declaration --&gt;
  &lt;name&gt;test&lt;/name&gt;

  &lt;!-- service declaration: sum (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b); --&gt;
  &lt;service&gt;
    &lt;name&gt;sum&lt;/name&gt;
    &lt;returns&gt;<span class="keywordtype">int</span>&lt;/returns&gt;
    &lt;params&gt;
      &lt;param&gt;
         &lt;name&gt;a&lt;/name&gt;
         &lt;type&gt;<span class="keywordtype">int</span>&lt;/type&gt;
      &lt;/param&gt;
      &lt;param&gt;
         &lt;name&gt;b&lt;/name&gt;
         &lt;type&gt;<span class="keywordtype">int</span>&lt;/type&gt;
      &lt;/param&gt;
    &lt;/params&gt;
    &lt;code&gt;
      &lt;content&gt;&lt;![CDATA[
        <span class="comment">/* this is a test &lt; &amp; */</span>
        <span class="keywordflow">return</span> a + b;
]]&gt;&lt;/content&gt;
 &lt;/code&gt;
  &lt;/service&gt;
&lt;/xml-rpc-interface&gt;
</pre></div><p>As you can see, <b>XDL format</b> is more verbose than IDL format, but provides a standard format to cross boundaries between process, it is easy to parse and it is more portable (there is a XML parser in every platform).</p>
<h2><a class="anchor" id="xml_rpc_gen_tool_language_types">
Types supported by xml-rpc-gen tool</a></h2>
<p>There are 6 basic types supported by the tool (well, it is more accurate to say by the XML-RPC definition) which are:</p>
<ul>
<li><b>int</b>: Integer definition, four-byte signed integer (-21)</li>
<li><b>boolean</b>: Boolean definition (bound to 1/axl_true, 0/axl_false)</li>
<li><b>double</b>: double-precision signed floating point number -412.21</li>
<li><b>string</b>: a string definition "XML-RPC over BEEP!!"</li>
<li><b>data</b>: date/time (currently not supported)</li>
<li><b>base64</b>: a base64 encoded string (currently encoding is not done).</li>
</ul>
<p>And two compound type definitions which allows to define more types:</p>
<ul>
<li><b>struct</b>: a struct definition which holds named values (called members).</li>
<li><b>array</b>: An uniform storage for other types (including more arrays).</li>
</ul>
<p>Struct and array types allows to create richer type definitions (even composing both). Here is an example that uses a struct declaration:</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment">
xml-rpc interface test {

        <span class="comment">/* declare the struct Values */</span>
        <span class="keyword">struct </span>Values {
                <span class="keywordtype">int</span>     count;
                <span class="keywordtype">double</span>  fraction;
                <span class="keywordtype">boolean</span> status;
        }

        <span class="comment">/* declare the service using previous declaration */</span>
        Values get_struct (Values a, Values b) {
                Values * result;

                <span class="comment">/* create the value to be returned */</span>
                result = test_values_new (a-&gt;count    +  b-&gt;count, 
                                          a-&gt;fraction +  b-&gt;fraction, 
                                          a-&gt;status   || b-&gt;status);
                
                <span class="comment">/* return the result provided */</span>
                <span class="keywordflow">return</span> result;
        }
}
</pre></div><p><b>XDL format:</b> </p>
<div class="fragment"><pre class="fragment">&lt;xml-rpc-interface&gt;
  &lt;!-- component name declaration --&gt;
  &lt;name&gt;test&lt;/name&gt;

  &lt;!-- <span class="keyword">struct </span>declaration --&gt;
  &lt;struct&gt;
    &lt;name&gt;Values&lt;/name&gt;
    &lt;member&gt;
      &lt;name&gt;count&lt;/name&gt;
      &lt;type&gt;int&lt;/type&gt;
    &lt;/member&gt;
    &lt;member&gt;
      &lt;name&gt;fraction&lt;/name&gt;
      &lt;type&gt;double&lt;/type&gt;
    &lt;/member&gt;
    &lt;member&gt;
      &lt;name&gt;status&lt;/name&gt;
      &lt;type&gt;boolean&lt;/type&gt;
    &lt;/member&gt;
  &lt;/struct&gt;

  &lt;!-- Values get_struct (Values a, Values b);              --&gt;
  &lt;!-- post: Returns the sum of the provided <span class="keyword">struct </span>values  --&gt;
  &lt;service&gt;
    &lt;name&gt;get_struct&lt;/name&gt;
    &lt;returns&gt;Values&lt;/returns&gt;
    &lt;params&gt;
     &lt;param&gt;
       &lt;name&gt;a&lt;/name&gt;
       &lt;type&gt;Values&lt;/type&gt;
     &lt;/param&gt;
     &lt;param&gt;
       &lt;name&gt;b&lt;/name&gt;
       &lt;type&gt;Values&lt;/type&gt;
     &lt;/param&gt;
    &lt;/params&gt;
    &lt;code&gt;
      &lt;content&gt;&lt;![CDATA[
        Values * result;

        <span class="comment">/* create the value to be returned */</span>
        result = test_values_new (a-&gt;count    +  b-&gt;count, 
                                  a-&gt;fraction +  b-&gt;fraction, 
                                  a-&gt;status   || b-&gt;status);
        
        <span class="comment">/* return the result provided */</span>
        <span class="keywordflow">return</span> result;
]]&gt;&lt;/content&gt;
 &lt;/code&gt;
  &lt;/service&gt;
&lt;/xml-rpc-interface&gt;
</pre></div><h2><a class="anchor" id="xml_rpc_gen_tool_language_recursive">
Recursive declarations with Struct</a></h2>
<p>You can also define recursive type declarations, which makes references to the type being defined. This allows, for example, to create a list with linked nodes represented by struct declarations. Here is an example:</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment">
xml-rpc interface test {

        <span class="comment">/* declare the struct Values */</span>
        <span class="keyword">struct </span>Node {
                <span class="keywordtype">int</span>  position;
                Node next;
        }

        <span class="comment">/* return a list, formed by nodes */</span>
        Node get_list () {
                <span class="comment">/* the pointer result */</span>
                Node * result;

                <span class="comment">/* some variables for the service */</span>
                Node * node;
                Node * next;
                <span class="keywordtype">int</span>    iterator = 2;

                <span class="comment">/* create the first node */</span>
                result = test_node_new (1, NULL);
                node   = result;
                <span class="keywordflow">while</span> (iterator &lt; 10) {

                        <span class="comment">/* create the next, but setting next as NULL</span>
<span class="comment">                         * because we don&#39;t have it yet */</span>
                        next = test_node_new (iterator, NULL);

                        <span class="comment">/* set previous the next created */</span>
                        node-&gt;next = next;

                        <span class="comment">/* update references */</span>
                        node = next;

                        <span class="comment">/* update index */</span>
                        iterator ++;
                }
                
                <span class="comment">/* return list created */</span>
                <span class="keywordflow">return</span> result;
        }
}
</pre></div><p><b>XDL format:</b> </p>
<div class="fragment"><pre class="fragment">&lt;xml-rpc-interface&gt;
  &lt;!-- XML-RPC component name declaration --&gt;
  &lt;name&gt;test&lt;/name&gt;

  &lt;!-- Node <span class="keyword">struct </span>declaration --&gt; 
  &lt;struct&gt;
     &lt;name&gt;Node&lt;/name&gt;
     &lt;member&gt;
        &lt;name&gt;position&lt;/name&gt;
        &lt;type&gt;int&lt;/type&gt;
     &lt;/member&gt;
     &lt;member&gt;
        &lt;name&gt;next&lt;/name&gt;
        &lt;type&gt;Node&lt;/type&gt;
     &lt;/member&gt;
  &lt;/struct&gt;

  &lt;!-- get_list service declaration --&gt;
  &lt;service&gt;
     &lt;name&gt;get_list&lt;/name&gt;
     &lt;returns&gt;Node&lt;/returns&gt;
     &lt;params&gt;
       &lt;!-- A service without parameters --&gt;
     &lt;/params&gt;
     &lt;code&gt;
        &lt;!-- service implementation declaration --&gt;
        &lt;content&gt;&lt;![CDATA[
                <span class="comment">/* the pointer result */</span>
                Node * result;

                <span class="comment">/* some variables for the service */</span>
                Node * node;
                Node * next;
                <span class="keywordtype">int</span>    iterator = 2;

                <span class="comment">/* create the first node */</span>
                result = test_node_new (1, NULL);
                node   = result;
                <span class="keywordflow">while</span> (iterator &lt; 10) {

                        <span class="comment">/* create the next, but setting next as NULL</span>
<span class="comment">                         * because we don&#39;t have it yet */</span>
                        next = test_node_new (iterator, NULL);

                        <span class="comment">/* set previous the next created */</span>
                        node-&gt;next = next;

                        <span class="comment">/* update references */</span>
                        node = next;

                        <span class="comment">/* update index */</span>
                        iterator ++;
                }
                
                <span class="comment">/* return list created */</span>
                <span class="keywordflow">return</span> result;
]]&gt;&lt;/content&gt;
     &lt;/code&gt;
  &lt;/service&gt;
&lt;/xml-rpc-interface&gt;
</pre></div><h2><a class="anchor" id="xml_rpc_gen_tool_language_considerations">
Considerations while using composing types: Struct and Arrays.</a></h2>
<p>There are several question to consider while using structures and arrays:</p>
<ul>
<li>There is no need to specify that the struct/array that is received or returned is a pointer type. There is no <b>*</b>. Types that are struct or arrays are used as basic types, referring to them by using its definition name. The same applies to <b>string</b> type definition.</li>
</ul>
<ul>
<li>You have to first define a type before using it. You can't use an struct/array definition if it is defined after it first use. However, there are exception: recursive definitions.</li>
</ul>
<ul>
<li>However, because the tool allows you to define source code inside the services to be included inside the server output, you have to use the pointer syntax. This could be obvious: remember that xml-rpc-gen tool just includes the source code. It doesn't perform any syntax validation.</li>
</ul>
<h2><a class="anchor" id="xml_rpc_gen_tool_language_array_declaration">
Array declaration</a></h2>
<p>Here is an example to define an array type (which is quite different from the array definition found in C/C#/Java):</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* hey emacs this is -*- c -*- mode */</span>

xml-rpc interface test {
        <span class="comment">/* struct declaration */</span>
        <span class="keyword">struct </span>Item {
                <span class="keywordtype">int</span>    position;
                <span class="keywordtype">string</span> string_position;
        }
        
        <span class="comment">/* array declaration */</span>
        array ItemArray of Item;
        
        <span class="comment">/* service declaration which returns the array */</span>
        ItemArray get_array () {

                ItemArray * result;
                Item      * item;
                <span class="keywordtype">int</span>         iterator;
                
                <span class="comment">/* create the item array */</span>
                result = test_itemarray_new (10);
                
                <span class="keywordflow">for</span> (iterator = 0; iterator &lt; 10; iterator++) {
                        <span class="comment">/* create the struct */</span>
                        item = test_item_new (iterator, <span class="stringliteral">&quot;test content&quot;</span>);
                        
                        <span class="comment">/* store it into the array */</span>
                        test_itemarray_set (result, iterator, item);
                }
                
                <span class="comment">/* put here service content */</span>
                <span class="keywordflow">return</span> result;          
        }
}
</pre></div><p><b>XDL format:</b> </p>
<div class="fragment"><pre class="fragment">&lt;xml-rpc-interface&gt;
  &lt;name&gt;test&lt;/name&gt;
  &lt;!-- Item <span class="keyword">struct </span>declaration --&gt;
  &lt;struct&gt;
    &lt;name&gt;Item&lt;/name&gt;
    &lt;member&gt;
      &lt;name&gt;position&lt;/name&gt;
      &lt;type&gt;int&lt;/type&gt;
    &lt;/member&gt;
    &lt;member&gt;
      &lt;name&gt;string_position&lt;/name&gt;
      &lt;type&gt;string&lt;/type&gt;
    &lt;/member&gt;
  &lt;/struct&gt;
  
  &lt;!-- array declaration --&gt;
  &lt;array&gt;
    &lt;name&gt;ItemArray&lt;/name&gt;
    &lt;type&gt;Item&lt;/type&gt;
    &lt;size&gt;0&lt;/size&gt;
  &lt;/array&gt;
  
  &lt;!-- ValuesArray get_array ();              --&gt;
  &lt;!-- post: Returns the sum of the provided <span class="keyword">struct </span>values  --&gt;
  &lt;service&gt;
    &lt;name&gt;get_array&lt;/name&gt;
    &lt;returns&gt;ItemArray&lt;/returns&gt;
    &lt;params&gt;
      &lt;!-- no param --&gt;
    &lt;/params&gt;
    &lt;code&gt;
      &lt;content&gt;&lt;![CDATA[
        ItemArray * result;
        Item      * item;
        <span class="keywordtype">int</span>         iterator;

        <span class="comment">/* create the item array */</span>
        result = test_itemarray_new (10);

        <span class="keywordflow">for</span> (iterator = 0; iterator &lt; 10; iterator++) {
                <span class="comment">/* create the struct */</span>
                item = test_item_new (iterator, <span class="stringliteral">&quot;test content&quot;</span>);

                <span class="comment">/* store it into the array */</span>
                test_itemarray_set (result, iterator, item);
        }
        
        <span class="comment">/* put here service content */</span>
        <span class="keywordflow">return</span> result;
        ]]&gt;&lt;/content&gt;
    &lt;/code&gt;
  &lt;/service&gt;
&lt;/xml-rpc-interface&gt;
</pre></div><h2><a class="anchor" id="xml_rpc_gen_tool_language_no_parameters">
Services without parameters</a></h2>
<p>Services could have no parameter. This is clear while using the IDL format, but for the XDL format, it is required to place the &lt;params&gt; declaration, with no &lt;param&gt; childs. Here is an example:</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* test interface with only one service that is called without</span>
<span class="comment"> * parameters and returns an string */</span>
xml-rpc interface test {
        
        <span class="keywordtype">string</span> get_the_string () {
                <span class="comment">/* return a test string (static version) */</span>
                <span class="keywordflow">return</span> axl_strdup (<span class="stringliteral">&quot;This is a test&quot;</span>);
        }
}
</pre></div><p><b>XDL format:</b> </p>
<div class="fragment"><pre class="fragment">&lt;xml-rpc-interface&gt;
  &lt;name&gt;test&lt;/name&gt;
  &lt;service&gt;
    &lt;name&gt;get_the_string&lt;/name&gt;
    &lt;returns&gt;<span class="keywordtype">string</span>&lt;/returns&gt;
    &lt;params&gt;
      &lt;!-- not parameters --&gt;
    &lt;/params&gt;
    &lt;code&gt;
      &lt;content&gt;&lt;![CDATA[
        <span class="comment">/* return a test string (static version) */</span>
        <span class="keywordflow">return</span> g_strdup (<span class="stringliteral">&quot;This is a test&quot;</span>);
]]&gt;&lt;/content&gt;
 &lt;/code&gt;
  &lt;/service&gt;
&lt;/xml-rpc-interface&gt;
</pre></div><h2><a class="anchor" id="xml_rpc_gen_tool_language_boolean">
Services using and returning boolean types</a></h2>
<p>Declaring services that receive or return boolean types is pretty straightforward. Here is an example:</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment">
xml-rpc interface test {
        <span class="keywordtype">boolean</span> get_the_bool_1 () {
                <span class="comment">/* return false */</span>
                <span class="keywordflow">return</span> FALSE;
        }

        <span class="keywordtype">boolean</span> get_the_bool_2 () {
                <span class="comment">/* return true */</span>
                <span class="keywordflow">return</span> TRUE;
        }
}
</pre></div><p><b>XDL format:</b> </p>
<div class="fragment"><pre class="fragment">&lt;xml-rpc-interface&gt;
  &lt;name&gt;test&lt;/name&gt;
  &lt;service&gt;
    &lt;!-- <span class="keywordtype">bool</span> get_the_bool_1 ();    --&gt;
    &lt;!-- post: Always returns <span class="keyword">false</span>  --&gt;
    &lt;name&gt;get_the_bool_1&lt;/name&gt;
    &lt;returns&gt;<span class="keywordtype">boolean</span>&lt;/returns&gt;
    &lt;params&gt;
      &lt;!-- not parameters --&gt;
    &lt;/params&gt;
    &lt;code&gt;
      &lt;content&gt;&lt;![CDATA[
        <span class="comment">/* return false */</span>
        <span class="keywordflow">return</span> FALSE;
]]&gt;&lt;/content&gt;
 &lt;/code&gt;
  &lt;/service&gt;
  &lt;service&gt;
    &lt;!-- <span class="keywordtype">bool</span> get_the_bool_2 ();    --&gt;
    &lt;!-- post: Always returns <span class="keyword">true</span>  --&gt;
    &lt;name&gt;get_the_bool_2&lt;/name&gt;
    &lt;returns&gt;<span class="keywordtype">boolean</span>&lt;/returns&gt;
    &lt;params&gt;
      &lt;!-- not parameters --&gt;
    &lt;/params&gt;
    &lt;code&gt;
      &lt;content&gt;&lt;![CDATA[
        <span class="comment">/* return true */</span>
        <span class="keywordflow">return</span> TRUE;
]]&gt;&lt;/content&gt;
 &lt;/code&gt;
  &lt;/service&gt;
&lt;/xml-rpc-interface&gt;
</pre></div><h2><a class="anchor" id="xml_rpc_gen_tool_language_double">
Services using and returning double types</a></h2>
<p>This is no special consideration while declaring services that makes use of the double type. Here is an example:</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* test double support, invoking a service with two double parameters,</span>
<span class="comment"> * and returning as a result another double */</span>
xml-rpc interface test {
        <span class="keywordtype">double</span> get_double_sum (<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b) {
                <span class="comment">/* return the sum */</span>
                <span class="keywordflow">return</span> a + b;
        }
}
</pre></div><p><b>XDL format:</b> </p>
<div class="fragment"><pre class="fragment">&lt;xml-rpc-interface&gt;
  &lt;name&gt;test&lt;/name&gt;
  &lt;!-- <span class="keywordtype">double</span> get_double_sum (<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b);          --&gt;
  &lt;!-- post: Returns the sum of the provided <span class="keywordtype">double</span> values  --&gt;
  &lt;service&gt;
    &lt;name&gt;get_double_sum&lt;/name&gt;
    &lt;returns&gt;<span class="keywordtype">double</span>&lt;/returns&gt;
    &lt;params&gt;
     &lt;param&gt;
       &lt;name&gt;a&lt;/name&gt;
       &lt;type&gt;<span class="keywordtype">double</span>&lt;/type&gt;
     &lt;/param&gt;
     &lt;param&gt;
       &lt;name&gt;b&lt;/name&gt;
       &lt;type&gt;<span class="keywordtype">double</span>&lt;/type&gt;
     &lt;/param&gt;
    &lt;/params&gt;
    &lt;code&gt;
      &lt;content&gt;&lt;![CDATA[
        <span class="comment">/* return the sum */</span>
        <span class="keywordflow">return</span> a + b;
]]&gt;&lt;/content&gt;
 &lt;/code&gt;
  &lt;/service&gt;
&lt;/xml-rpc-interface&gt;
</pre></div><h2><a class="anchor" id="xml_rpc_gen_tool_changing_method_name">
Changing the method name for a service declared</a></h2>
<p>Due to the kind of output produced by the xml-rpc-gen tool, it has to create "method names" for services declared at the IDL processed in a synchronized way to a client invocation, using a particular service, is properly processed by the remote service entry point.</p>
<p>Under some situations it is required to change the name that used by default the xml-rpc-gen tool. This is done by using a prefix declaration before the service: </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* af-arch service definition to invoke them easily using the idl</span>
<span class="comment"> * compiler */</span>
xml-rpc interface af-arch {
        
        <span class="keyword">struct </span>HostLocation {
                <span class="comment">/* logical name */</span>
                <span class="keywordtype">string</span> name;

                <span class="comment">/* server host location */</span>
                <span class="keywordtype">string</span> host;

                <span class="comment">/* server port location */</span>
                <span class="keywordtype">string</span> port;
        }

        <span class="comment">/* an array of host location items */</span>
        array HostLocationArray of HostLocation;
        
        [method_name=<span class="stringliteral">&quot;af_kernel::server::get_list&quot;</span>];
        HostLocationArray get_list ();

} <span class="comment">/* end af-arch interface */</span>
</pre></div><p>In the example, the service <b>get_list</b> won't be invoked using that name (the default xml-rpc-gen behavior), but the name declared at the <b>method_name</b> will be used.</p>
<p>Previous IDL declaration is used by shaper to invoke a service exported by the Af-Arch central server, through the XML-RPC bridge, to get host location information.</p>
<h2><a class="anchor" id="xml_rpc_gen_tool_using_resources">
Using resources to group your services</a></h2>
<p>During the XML-RPC channel negotiation phase, the client request to create a channel under a particular <b>resource</b>. By default all services declared at the IDL are grouped under the same resource: <b>"/"</b>.</p>
<p>This <b>resource</b> declaration can be used in several ways to achieve some interesting features:</p>
<ul>
<li>If services provided by your server are grouped into a defined resource, different from the default ("/"), it is possible to use that resource at the <a class="el" href="group__vortex__xml__rpc_gaa4200cc2dfd02845f16ad819389391ae.html#gaa4200cc2dfd02845f16ad819389391ae">validate resource handler</a> to allow client applications to know if the set of desired services are exported by the server component.</li>
</ul>
<ul>
<li>Grouping services under several resources improves service dispatching efficiency mainly because it is not required to check all services (under the same resource) to perform the dispatch operation.</li>
</ul>
<p>To change the resource under which the service is grouped you must use the attribute <b>"resource"</b> as used in: <a class="el" href="programming__with__xml__rpc.html#xml_rpc_gen_tool_changing_method_name">Changing the method name for a service declared</a>.</p>
<div class="fragment"><pre class="fragment">xml-rpc interface test  {
        
        [resource=<span class="stringliteral">&quot;arimetic-operations&quot;</span>];
        <span class="keywordtype">int</span> sum (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {
                <span class="keywordflow">return</span> a + b;
        }
} 
</pre></div><p>Note this will produce a client and a server component that handles the service under the provided resource. However the <a class="el" href="group__vortex__xml__rpc_gaa4200cc2dfd02845f16ad819389391ae.html#gaa4200cc2dfd02845f16ad819389391ae">validation handler</a> is not provided.</p>
<h2><a class="anchor" id="xml_rpc_gen_tool_enforce_resources">
Enforcing resources to be used at the IDL</a></h2>
<p>Previous section provided information about declaring resources and grouping services under them. However, knowing that a resource declaration is a string, it could be required to enforce resources that are usable across the IDL. This is done by using the following:</p>
<div class="fragment"><pre class="fragment"> allowed resources <span class="stringliteral">&quot;resource1&quot;</span>, <span class="stringliteral">&quot;resource2&quot;</span>, <span class="stringliteral">&quot;resource3&quot;</span>;
</pre></div><p>This list declaration must be used before any service with the attribute <b>"resource"</b>. The list configured will enforce the xml-rpc-gen tool to allow and check all resources used.</p>
<h2><a class="anchor" id="xml_rpc_gen_tool_including_body_code">
Including additional code to be placed at the service module file</a></h2>
<p>Examples showed allows to include code that is placed at the appropriate file at the server side created. However, real situation requires calling to functions that are defined at the same modules or other modules. This is because it is required a mechanism that allows to include arbitrary code, not only in the service body.</p>
<p>Suppose the following example:</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* include example */</span>
xml-rpc interface test {
        <span class="comment">/* add two integers */</span>
        <span class="keywordtype">int</span> sum (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {

                <span class="comment">/* sum values received */</span>
                <span class="keywordflow">return</span> do_sum_operation (a, b);

        } options {
                include on body {
                        <span class="keywordtype">int</span> do_sum_operation (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {
                                <span class="keywordflow">return</span> a + b;
                        } <span class="comment">/* do_sum_operation */</span>
                } <span class="comment">/* end include on body */</span>
        }
}
</pre></div><p>The service <b>sum</b> is implemented making a call to a user defined function <b>do_sum_operation</b>. Using the <em>"include on
 body"</em> declaration it is possible to include the content of the function. The content provide will be included at the top of the body implementation for the service <b>sum</b> to avoid prototypes.</p>
<p>There is also a way to include content into the module header. This is done using the same structure: <em>"include on header"</em>.</p>
<p>In the case the body content to be included is to large you can place it into a file and make the tool to include it. This is done as follows:</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* include example */</span>
xml-rpc interface test {
        <span class="comment">/* add two integers */</span>
        <span class="keywordtype">int</span> sum (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {

                <span class="comment">/* sum values received */</span>
                <span class="keywordflow">return</span> do_sum_operation (a, b);

        } options {
                include on body <span class="stringliteral">&quot;do_sum_operation.c&quot;</span>;
        }
}
</pre></div><p>In this case the implementation of the <b>do_sum_operation</b> is included at the file: <em>"do_sum_operation.c"</em>. The same applies to the content included at the module header file.</p>
<h2><a class="anchor" id="xml_rpc_gen_tool_using_output_client">
Using the output produced by xml-rpc-gen tool at the CLIENT SIDE</a></h2>
<p>The output produced by the tool are two software pieces: the client stub library and the server component. The client stub is small library that hides all the details to produce the invocation, marshalling all data, and to unmarshall replies received.</p>
<p>Let's recall our first example, to see what is the result generated for the client stub:</p>
<p><b>IDL format:</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* This is a test that invokes a simple service with two integers and</span>
<span class="comment"> * returns its result.</span>
<span class="comment"> */</span>
xml-rpc interface test {
        <span class="comment">/* add two integers */</span>
        <span class="keywordtype">int</span> sum (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {
                <span class="comment">/* sum values received */</span>
                <span class="keywordflow">return</span> a + b;
        }

        <span class="comment">/* empty service definition */</span>
        <span class="keywordtype">int</span> operate (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b);
}
</pre></div><p>If previous example is compiled (supposing the file is located at reg-test01.idl) as follows:</p>
<div class="fragment"><pre class="fragment"> bash:~$ xml-rpc-gen reg-test01.idl
</pre></div><p>By default, the client library is placed at: <b>out/client-&lt;component-name&gt;</b>. In this case, the output will be <b>out/client-test</b>. You can modify this behavior by using the <b>--out-dir</b> switch.</p>
<p>Inside a the <b>out/client-test</b> directory you'll find the main API file <b>out/client-test/test_xml_rpc.h</b>. This file contains all invocation functions required to perform a method call to all services exported by the component compiled.</p>
<p>Again, this file will follow the next naming convention according to the component name: <b>out/client-&lt;component-name&gt;/&lt;component-name&gt;_xml_rpc.h</b></p>
<p>Let's see its content:</p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#ifndef __XML_RPC_TEST_H__</span>
<span class="preprocessor"></span><span class="preprocessor">#define __XML_RPC_TEST_H__</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;test_types.h&gt;</span>
<span class="comment">/* include base library */</span>
<span class="preprocessor">#include &lt;vortex.h&gt;</span>
<span class="comment">/* include xml-rpc library */</span>
<span class="preprocessor">#include &lt;vortex_xml_rpc.h&gt;</span>

<span class="comment">/* support for c++ declarations */</span>
BEGIN_C_DECLS

<span class="comment">/* service: sum */</span>
<span class="keywordtype">int</span> test_sum_int_int_s (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a> * channel, <a class="code" href="group__vortex__xml__rpc__types_ga4d776daa7b02e9c49a6633ae00002f6b.html#ga4d776daa7b02e9c49a6633ae00002f6b" title="Represents current XmlRpc status operation.">XmlRpcResponseStatus</a> * status, <span class="keywordtype">int</span> * fault_code, <span class="keywordtype">char</span> ** fault_string);
<span class="keywordtype">void</span> test_sum_int_int (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a> * channel, <a class="code" href="group__vortex__xml__rpc__types_ga9cd2359a9d97692986f81fb7f6e40f4b.html#ga9cd2359a9d97692986f81fb7f6e40f4b" title="Async reply notification for XML-RPC services that returns as a result an integer...">XmlRpcProcessInt</a> process);

<span class="comment">/* service: operate */</span>
<span class="keywordtype">int</span> test_operate_int_int_s (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a> * channel, <a class="code" href="group__vortex__xml__rpc__types_ga4d776daa7b02e9c49a6633ae00002f6b.html#ga4d776daa7b02e9c49a6633ae00002f6b" title="Represents current XmlRpc status operation.">XmlRpcResponseStatus</a> * status, <span class="keywordtype">int</span> * fault_code, <span class="keywordtype">char</span> ** fault_string);
<span class="keywordtype">void</span> test_operate_int_int (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a> * channel, <a class="code" href="group__vortex__xml__rpc__types_ga9cd2359a9d97692986f81fb7f6e40f4b.html#ga9cd2359a9d97692986f81fb7f6e40f4b" title="Async reply notification for XML-RPC services that returns as a result an integer...">XmlRpcProcessInt</a> process);


END_C_DECLS

<span class="preprocessor">#endif</span>
</pre></div><p>As you can see, there are two function declarations for every service exported by the XML-RPC component compiled. Both represent the same service to be invoked, however, one serve as a synchronous invocation, the one with the prefix <b>"_s"</b> and the other one serves for the asynchronous (non-blocking) invocation.</p>
<p>In the synchronous invocation case, the function ending with <b>"_s"</b>, you'll find all parameters specified in the IDL/XDL definition, in this case: <b><em>int a, and int b</em></b>, plus three additional parameters, that are optional, and helps to get invocation error reporting.</p>
<ul>
<li><a class="el" href="group__vortex__xml__rpc__types_ga4d776daa7b02e9c49a6633ae00002f6b.html#ga4d776daa7b02e9c49a6633ae00002f6b">XmlRpcResponseStatus</a> <b>status</b>: Allows to get current invocation status (<a class="el" href="group__vortex__xml__rpc__types_ga4d776daa7b02e9c49a6633ae00002f6b.html#gga4d776daa7b02e9c49a6633ae00002f6ba0d6381d233a422990b6b5f50d9291570">XML_RPC_OK</a>) or (<a class="el" href="group__vortex__xml__rpc__types_ga4d776daa7b02e9c49a6633ae00002f6b.html#gga4d776daa7b02e9c49a6633ae00002f6ba23fe7a0d36be17b60f41322fc7b61f33">XML_RPC_FAIL</a> and the rest of fail errors).</li>
</ul>
<ul>
<li><b>int * fault_code</b>: allows to get a integer fault code, defined by the remote service (actually defined by the service developer). This is a custom value not defined by the framework. See <a class="el" href="group__vortex__xml__rpc__types_ga025c234cbdc66286c3a20ff06bae692f.html#ga025c234cbdc66286c3a20ff06bae692f">REPLY_FAULT</a>.</li>
</ul>
<ul>
<li><b>char ** fault_string</b>: allows to get the error string, a textual diagnostic string, defined by the remote service. Again, see <a class="el" href="group__vortex__xml__rpc__types_ga025c234cbdc66286c3a20ff06bae692f.html#ga025c234cbdc66286c3a20ff06bae692f">REPLY_FAULT</a>. <em><b>NOTE:</b> While using the synchronous invocation, and this variable is provided and an error is found, then this string holding the textual diagnostic must be deallocated after using it using: axl_free.</em></li>
</ul>
<p>Apart from the service parameters, in both cases, synchronous and asynchronous, you must also provide a reference to a <a class="el" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f">VortexChannel</a> already initialized (XML-RPC booted), with the XML-RPC profile, and under the particular resource where the service will be run.</p>
<p>To boot a channel there are several functions provided:</p>
<ul>
<li><a class="el" href="group__vortex__xml__rpc_gad8eed31174fe5920a5fb7abf1c167e01.html#gad8eed31174fe5920a5fb7abf1c167e01">vortex_xml_rpc_boot_channel</a> that will create a <a class="el" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f">VortexChannel</a> running the XML-RPC profile, in an asynchronous way, without blocking the caller and notifying once the creation process have finished (without considering its termination status).</li>
</ul>
<ul>
<li><a class="el" href="group__vortex__xml__rpc_gaa2040e191f21955507699049341ee15c.html#gaa2040e191f21955507699049341ee15c">vortex_xml_rpc_boot_channel_sync</a> that will create a <a class="el" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f">VortexChannel</a> running the XML-RPC profile, in a synchronous way, blocking the caller until the process is totally finished.</li>
</ul>
<ul>
<li><a class="el" href="group__vortex__xml__rpc_ga92b15e4f7bed65245da0619a5ff1e3cf.html#ga92b15e4f7bed65245da0619a5ff1e3cf">BOOT_CHANNEL</a> (alias to <a class="el" href="group__vortex__xml__rpc_gad8eed31174fe5920a5fb7abf1c167e01.html#gad8eed31174fe5920a5fb7abf1c167e01">vortex_xml_rpc_boot_channel</a>).</li>
</ul>
<p>Finally, the asynchronous API is the same as the synchronous, providing the service parameters, the channel where the invocation will be run, and a handler where the service reply will be notified.</p>
<p>Now we know a bit more about the main API created by the xml-rpc-gen tool, the file <b>test_xml_rpc.h</b>. However, you also have to take a look to <b>test_types.h</b> file. It contains all complex type definitions, that is, struct and array declarations. In this case, that file is empty.</p>
<p><em><b>NOTE:</b> Both products generated, <b>client-test</b> and <b>server-test</b> have support for auto-tools. You have to follow the standard process to configure and compile:</em></p>
<p><em> </p>
<div class="fragment"><pre class="fragment">  bash:~$ cd Test/out/client-test
  bash:~/Test/out/client-test$ ./autogen
  bash:~/Test/out/client-test$ ./make
  bash:~/Test/out/client-test$ ./make install
</pre></div><p> </em></p>
<p>Ok, but, what about performing an invocation using this files. Here is a simple example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;test_xml_rpc.h&gt;</span>

<span class="keywordtype">int</span>  main (<span class="keywordtype">int</span>  argc, <span class="keywordtype">char</span> ** argv)
{
        <a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection;
        <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a>    * channel;

        <span class="comment">/* initialize the vortex */</span>
        vortex_init ();

        <span class="comment">/* create a connection to a local server */</span>
        connection = <a class="code" href="group__vortex__connection_ga727b938695d1037058256e3559d9d599.html#ga727b938695d1037058256e3559d9d599" title="Allows to create a new BEEP session (connection) to the given host:port.">vortex_connection_new</a> (<span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;44000&quot;</span>, NULL, NULL);

        <span class="comment">/* create the xml-rpc channel */</span>
        channel = <a class="code" href="group__vortex__xml__rpc_ga92b15e4f7bed65245da0619a5ff1e3cf.html#ga92b15e4f7bed65245da0619a5ff1e3cf" title="Allows to boot an XML-RPC channel, in a synchronous way, calling to vortex_xml_rpc_boot_channel_sync...">BOOT_CHANNEL</a> (connection, NULL);

        <span class="comment">/* perform the invocation */</span>
        <span class="keywordflow">if</span> (7 != test_sum_int_int_s (3, 4, channel, NULL, NULL, NULL)) {
                fprintf (stderr, <span class="stringliteral">&quot;An error was found while invoking..\n&quot;</span>);
                <span class="keywordflow">return</span> -1;
        }

        <span class="comment">/* close the channel */</span>
        <a class="code" href="group__vortex__channel_gac355276dbcfb7b95eb074d55292a6e3e.html#gac355276dbcfb7b95eb074d55292a6e3e" title="Close the given channel.">vortex_channel_close</a> (channel, NULL);   

        <span class="comment">/* close the connection */</span>
        <a class="code" href="group__vortex__connection_gaa2cfa2eb776f65ce6805247f53cc1067.html#gaa2cfa2eb776f65ce6805247f53cc1067" title="Tries to close properly a connection and all channels inside it.">vortex_connection_close</a> (connection);

        <span class="comment">/* terminate vortex */</span>
        vortex_exit (); 

        <span class="keywordflow">return</span> 0;
}
</pre></div><p>In the test we didn't perform any check, which isn't a good thing, (using <a class="el" href="group__vortex__connection_ga130045a0527441a1c20332cad32f0f4d.html#ga130045a0527441a1c20332cad32f0f4d">vortex_connection_is_ok</a> to check the connection, checking for NULL reference the channel created, and providing some variables to get invocation status, etc), but it helps you to get an idea.</p>
<h2><a class="anchor" id="xml_rpc_gen_tool_using_output_listener">
Using the output produced by xml-rpc-gen tool at the LISTENER SIDE</a></h2>
<p>Following the example of the previous section, there is not too much to say. You have to compile the server and then run it. Try to compile the previous example and to compile the server as follows:</p>
<div class="fragment"><pre class="fragment">  bash:~$ cd Test/out/server-test
  bash:~/Test/out/server-test$ ./autogen
  bash:~/Test/out/server-test$ ./make
  bash:~/Test/out/server-test$ ./make install
  bash:~/Test/out/server-test$ ./server-test
</pre></div><p>Because xml-rpc-gen tool have support to include the service source code definition, into the IDL/XDL definition, the compiled product only required to be compiled. However programing a XML-RPC service usually is more complex than adding two integer. Here are some considerations:</p>
<p>If the server component is produced (by default client and server components are produced but it can be configured by using <b>--only-client</b> or <b>--only-server</b>), it contains a xml file that allows to configure the TCP/IP location. Look at: <b>out/server-test/conf.xml</b>. Here is the content:</p>
<div class="fragment"><pre class="fragment">&lt;vortex-listener&gt;
  &lt;listener&gt;
     &lt;hostname&gt;0.0.0.0&lt;/hostname&gt;
     &lt;port&gt;44000&lt;/port&gt;
  &lt;/listener&gt;
&lt;/vortex-listener&gt;
</pre></div><p>You can modify and add more &lt;listener&gt; nodes to make your XML-RPC component to listen in other ports than the default one (produced 0.0.0.0:44000). It is supposed that the IANA authority have registered the 602 TCP port for the XML-RPC over BEEP protocol, but this isn't required.</p>
<p>While programming the server component, inside the IDL/XDL file, you'll have to use the <a class="el" href="group__vortex__xml__rpc__types_ga025c234cbdc66286c3a20ff06bae692f.html#ga025c234cbdc66286c3a20ff06bae692f">REPLY_FAULT</a> macro if you want to reply to the client component a faultCode and a faultString. The first two parameters are the fault string and the fault code. The last one is the empty value to be returned in order to compile the server. In most cases you can use 0.</p>
<p>If the service returns pointer types: <a class="el" href="group__vortex__xml__rpc__types_gaa29cfe7b792cedbe00f70786a4d5e9f1.html#ggaa29cfe7b792cedbe00f70786a4d5e9f1aa70872397b308525e219da642687a00b">XML_RPC_STRING_VALUE</a>, <a class="el" href="group__vortex__xml__rpc__types_gaa29cfe7b792cedbe00f70786a4d5e9f1.html#ggaa29cfe7b792cedbe00f70786a4d5e9f1a0e7775f6f546177430072b4745915c22">XML_RPC_STRUCT_VALUE</a> and <a class="el" href="group__vortex__xml__rpc__types_gaa29cfe7b792cedbe00f70786a4d5e9f1.html#ggaa29cfe7b792cedbe00f70786a4d5e9f1a5abe2a93c06bebec5b6b9a4e8b7ef917">XML_RPC_ARRAY_VALUE</a>, all of them must return dynamically allocated objects. They will be deallocated by the XML-RPC engine, at the proper time.</p>
<h2><a class="anchor" id="xml_rpc_authentication_and_security">
XML-RPC authentication and Security</a></h2>
<p>Until now, we didn't talk too much about these topics, mainly because they are fully integrated with the BEEP environment, and hence, inside Vortex Library. However, for those new to BEEP, here are some tips about this issue.</p>
<p>Every profile implemented on top of BEEP (the protocol) have already-made support to authenticate peers using <a class="el" href="starting__to__program.html#vortex_manual_using_sasl">SASL</a> and to secure connections using <a class="el" href="starting__to__program.html#vortex_manual_securing_your_session">TLS</a>.</p>
<p>So, in the case a secure invocation is required you'll have to first create a connection with the XML-RPC listener, and then secure that connection. Then, once the connection is secured, perform the invocation creating channels as usual. All this tasks could be considered as client side one. Look at the following document to know about this issue: <a class="el" href="starting__to__program.html#vortex_manual_securing_your_session">5.1 Securing a Vortex Connection (or How to use the TLS profile)</a>.</p>
<p>At the server side you have to provide the enough mechanism to allow/ensure the client that is connected is doing so in a proper way. You can implement all your security politics at the <a class="el" href="group__vortex__handlers_ga80c00e4df48fb1740c5946bbdeea7d90.html#ga80c00e4df48fb1740c5946bbdeea7d90">start handler</a> or at the <a class="el" href="group__vortex__xml__rpc_gaa4200cc2dfd02845f16ad819389391ae.html#gaa4200cc2dfd02845f16ad819389391ae">resource validation handler</a>. Unless it is required some special TLS function at the server side, like identifying the client certificate, it is not required to implement anything special. Look at the following document with provides a default TLS environment: <a class="el" href="starting__to__program.html#vortex_manual_securing_your_session">5.1 Securing a Vortex Connection (or How to use the TLS profile)</a>.</p>
<p>Because Vortex Library, at this moment, doesn't provide a profile path, allowing to hide non-secured profiles behind TLS or SASL profiles until they are entirely negotiated, you have to ensure that TLS is already activated, before accepting to dispatch a function, at the <a class="el" href="group__vortex__xml__rpc_ga430cc7a9c84542ed680883355617bf79.html#ga430cc7a9c84542ed680883355617bf79">service dispatch handler</a>. See also <a class="el" href="group__vortex__connection_ga418ee4df18dd89a6363c67fa8e24ba6c.html#ga418ee4df18dd89a6363c67fa8e24ba6c">vortex_connection_is_tlsficated</a> for more details.</p>
<p>The same philosofy applies to the authentication problem. You have to first establish the user authentication (and its authorization) and the perform the XML-RPC invocation. This means that, for a connection, first it is required to activate the user authentication through the <a class="el" href="group__vortex__sasl.html">SASL API</a>, and then perform the XML-RPC invocation as normal.</p>
<p>Then, at the server side, inside the service dispatch function, the listener must check the connection credentials already activated to ensure the user that is actually executing the XML-RPC method, is allowed to do so. See the following document to know more about this: <a class="el" href="starting__to__program.html#vortex_manual_using_sasl">5.3 Authenticating BEEP peers (or How to use SASL profiles family)</a>.</p>
<p>To summarize, there is no way to describe the <b>"unique security and authentication"</b> solution inside BEEP. Authentication (SASL), Security (TLS) and, for this case, the XML-RPC invocation mechanism are implemented in an independent way, like blocks that must be combined and mixed to build your specific solution that meets your requirements.</p>
<p>Maybe you only require to use TLS, or maybe you just need to do a SASL plain auth. However, the key concept is that: your required provisioning mechanism must be first activated before you actually perform useful work. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="lateral-ad">
  <iframe src="http://www.aspl.es/web-ads/index.php?hcolor=fdff4f&amp;fsize=10&amp;bg=555753&amp;fg=ffffff&amp;width=150&amp;type=vertical" height="420" align="middle" width="100%" scrolling="no" frameborder="0"></iframe>
</div>
<div class="footer">
<small>Vortex Library:  A BEEP (RFC3080/RFC3081) implementation. &nbsp; Copyright 2008 (C) Advanced Software Production Line, S.L.</small>
</div>
</body>
</html>

