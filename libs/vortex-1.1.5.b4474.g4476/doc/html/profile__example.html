<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>Vortex Library, BEEP Core implementation, RFC 3080 / RFC 3081, XML-RPC, XML-RPC over BEEP, RFC 3529, BEEP Framework, BEEP protocol, BEEP, BEEP library, BEEP libraries, beepcore (Servidores Linux http://www.aspl.es)</title>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-123192-2";
urchinTracker();
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="vortex.css" rel="stylesheet" type="text/css">
</head>
  <body>
    <div class="af-arch-header">
     <img src="main-page-logo.png" > <a href="http://www.aspl.es"><img class="aspl-logo-header" src="aspl-logo-header.png"></a>
    </div>
    <div class="ads">
    <iframe src="http://www.aspl.es/web-ads/index.php?hcolor=fdff4f&amp;fsize=10&amp;bg=555753&amp;fg=ffffff&amp;width=800&amp;height=90" scrolling="no" frameborder="0"></iframe> 
    </div>
    <div class="separator">
    </div>
<div class="thepage">

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="profile_example">Implementing a profile tutorial (C API) </a></h1><h2><a class="anchor" id="profile_example_intro">
Introduction</a></h2>
<p><em><b>NOTE:</b> All code developed on this tutorial can be found inside the Vortex Library repository, inside the <b>test/</b> directory. Files created in this tutorial: vortex-simple-listener.c and vortex-simple-client.c. The following are the subversion links: </em></p>
<ul>
<li><a href="https://dolphin.aspl.es/svn/publico/af-arch/trunk/libvortex-1.1/test/vortex-simple-client.c">https://dolphin.aspl.es/svn/publico/af-arch/trunk/libvortex-1.1/test/vortex-simple-client.c</a></li>
<li><a href="https://dolphin.aspl.es/svn/publico/af-arch/trunk/libvortex-1.1/test/vortex-simple-listener.c">https://dolphin.aspl.es/svn/publico/af-arch/trunk/libvortex-1.1/test/vortex-simple-listener.c</a></li>
</ul>
<p>We are going to create a simple server which implements a simple profile defined as: <em>every message it receives, is replied with the payload received appending "Received OK: ".</em></p>
<p>Additionally, we are going to create a simple client which tries to connect to the server and then send a message to him printing to the console the server's reply.</p>
<p>The profile implemented is called <em>"http://fact.aspl.es/profiles/plain_profile"</em>. While implementing a profile you must chose a name based on a uri style. You can't chose already defined profiles name so it is a good idea to chose your profile name appending as prefix your project name. An example of this can be: <em>"http://your.project.org/profiles/profile_name"</em>.</p>
<p>See how the <em>plain_profile</em> is implemented to get an idea on how more complex, and useful profiles could be implemented.</p>
<h2><a class="anchor" id="profile_example_server">
Implementing the server.</a></h2>
<p>First, we have to create the source code for the server:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;vortex.h&gt;</span>

<span class="preprocessor">#define PLAIN_PROFILE &quot;http://fact.aspl.es/profiles/plain_profile&quot;</span>
<span class="preprocessor"></span>
<span class="comment">/* listener context */</span>
<a class="code" href="group__vortex__types_ga879b03a2476b60c5b9b75489aabfe7db.html#ga879b03a2476b60c5b9b75489aabfe7db" title="Vortex library context.">VortexCtx</a> * ctx = NULL;

<span class="keywordtype">void</span> frame_received (<a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a>    * channel,
                     <a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection,
                     <a class="code" href="group__vortex__types_gac830c777ca317921af4cf7c038dcf8b7.html#gac830c777ca317921af4cf7c038dcf8b7" title="A Vortex Frame object.">VortexFrame</a>      * frame,
                     axlPointer           user_data)
{
        printf (<span class="stringliteral">&quot;A frame received on channl: %d\n&quot;</span>,     <a class="code" href="group__vortex__channel_ga9400e3eebd4c4816c7d6164fa776f0de.html#ga9400e3eebd4c4816c7d6164fa776f0de" title="Returns the channel number for selected channel.">vortex_channel_get_number</a> (channel));
        printf (<span class="stringliteral">&quot;Data received: &#39;%s&#39;\n&quot;</span>,                (<span class="keywordtype">char</span>*) <a class="code" href="group__vortex__frame_ga2ac165d800ebaca853c7a2634e5c6de4.html#ga2ac165d800ebaca853c7a2634e5c6de4" title="Returns the payload associated to the given frame.">vortex_frame_get_payload</a> (frame));

        <span class="comment">/* reply the peer client with the same content */</span>
        <a class="code" href="group__vortex__channel_ga0a7d3b38262723d8614a5654db6f48aa.html#ga0a7d3b38262723d8614a5654db6f48aa" title="printf-like version for vortex_channel_send_rpy function.">vortex_channel_send_rpyv</a> (channel,
                                  <a class="code" href="group__vortex__frame_ga0ecac42a92d4a585a068c99bb63529dc.html#ga0ecac42a92d4a585a068c99bb63529dc" title="Return current message number used for the given frame.">vortex_frame_get_msgno</a> (frame),
                                  <span class="stringliteral">&quot;Received Ok: %s&quot;</span>,
                                  <a class="code" href="group__vortex__frame_ga2ac165d800ebaca853c7a2634e5c6de4.html#ga2ac165d800ebaca853c7a2634e5c6de4" title="Returns the payload associated to the given frame.">vortex_frame_get_payload</a> (frame));
                                
        printf (<span class="stringliteral">&quot;VORTEX_LISTENER: end task (pid: %d)\n&quot;</span>, getpid ());


        <span class="keywordflow">return</span>;
}

<span class="keywordtype">int</span>      start_channel (<span class="keywordtype">int</span>                channel_num, 
                        <a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection, 
                        axlPointer           user_data)
{
        <span class="comment">/* implement profile requirement for allowing starting a new</span>
<span class="comment">         * channel */</span>

        <span class="comment">/* to return axl_false denies channel creation to return axl_true</span>
<span class="comment">         * allows create the channel */</span>
        <span class="keywordflow">return</span> axl_true;
}

<span class="keywordtype">int</span>      close_channel (<span class="keywordtype">int</span>                channel_num, 
                        <a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection, 
                        axlPointer           user_data)
{
        <span class="comment">/* implement profile requirement for allowing to closeing a</span>
<span class="comment">         * the channel to return axl_false denies channel closing to</span>
<span class="comment">         * return axl_true allows to close the channel */</span>
        <span class="keywordflow">return</span> axl_true;
}

<span class="keywordtype">int</span>      on_accepted (<a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection, axlPointer data)
{
        printf (<span class="stringliteral">&quot;New connection accepted from: %s:%s\n&quot;</span>, 
                 <a class="code" href="group__vortex__connection_gaa018aaa5a4bde338f20fe0c623cc11e1.html#gaa018aaa5a4bde338f20fe0c623cc11e1" title="Returns the actual host this connection is connected to.">vortex_connection_get_host</a> (connection),
                 <a class="code" href="group__vortex__connection_ga792c4db55334ee7193da9ecaa66cb06a.html#ga792c4db55334ee7193da9ecaa66cb06a" title="Returns the actual port this connection is connected to.">vortex_connection_get_port</a> (connection));

        <span class="comment">/* return axl_true to accept the connection to be created */</span>
        <span class="keywordflow">return</span> axl_true;
}

<span class="keywordtype">int</span>  main (<span class="keywordtype">int</span>  argc, <span class="keywordtype">char</span> ** argv) 
{

        <span class="comment">/* create the context */</span>
        ctx = <a class="code" href="group__vortex__ctx_gada9a1d87bfe28dd117f6d6b4356d6e31.html#gada9a1d87bfe28dd117f6d6b4356d6e31" title="Creates a new vortex execution context.">vortex_ctx_new</a> ();

        <span class="comment">/* init vortex library */</span>
        <span class="keywordflow">if</span> (! <a class="code" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280" title="Context based vortex library init.">vortex_init_ctx</a> (ctx)) {
                <span class="comment">/* unable to init context */</span>
                <a class="code" href="group__vortex__ctx_gad51a75c61479db09ae1619b2a8b15b7d.html#gad51a75c61479db09ae1619b2a8b15b7d" title="Releases the memory allocated by the provided VortexCtx.">vortex_ctx_free</a> (ctx);

                <span class="keywordflow">return</span> -1;
        } <span class="comment">/* end if */</span>

        <span class="comment">/* register a profile */</span>
        <a class="code" href="group__vortex__profiles_ga090a544dbe5097f9608401c405f913ff.html#ga090a544dbe5097f9608401c405f913ff" title="Allows to register a new profile inside the Vortex Library.">vortex_profiles_register</a> (ctx, PLAIN_PROFILE, 
                                  start_channel, NULL, 
                                  close_channel, NULL,
                                  frame_received, NULL);

        <span class="comment">/* create a vortex server */</span>
        <a class="code" href="group__vortex__listener_ga9745c0a637eb270f60b290efe5193352.html#ga9745c0a637eb270f60b290efe5193352" title="Creates a new Vortex Listener accepting incoming connections on the given host:port...">vortex_listener_new</a> (ctx, <span class="stringliteral">&quot;0.0.0.0&quot;</span>, <span class="stringliteral">&quot;44000&quot;</span>, NULL, NULL);

        <span class="comment">/* configure connection notification */</span>
        <a class="code" href="group__vortex__listener_gae997c972c5e7b00f2d36ca9367c41eea.html#gae997c972c5e7b00f2d36ca9367c41eea" title="Allows to configure a handler that is executed once a connection have been accepted...">vortex_listener_set_on_connection_accepted</a> (ctx, on_accepted, NULL);

        <span class="comment">/* wait for listeners (until vortex_exit is called) */</span>
        <a class="code" href="group__vortex__listener_ga8c905a74e007c89508b3add33e595c53.html#ga8c905a74e007c89508b3add33e595c53" title="Blocks a listener (or listeners) launched until vortex finish.">vortex_listener_wait</a> (ctx);
        
        <span class="comment">/* end vortex function */</span>
        <a class="code" href="group__vortex_ga755d3c8fb55979c25c5abb1ab3939faa.html#ga755d3c8fb55979c25c5abb1ab3939faa" title="Terminates the vortex library execution on the provided context.">vortex_exit_ctx</a> (ctx, axl_true);

        <span class="keywordflow">return</span> 0;
}

</pre></div><p>As you can see, the server code is fairly easy to understand. The following steps are done: </p>
<ul>
<li>
<p class="startli">First of all, Vortex Library is initialized using <a class="el" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280">vortex_init_ctx</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Then, <em>PLAIN_PROFILE</em> is registered inside Vortex Library using <a class="el" href="group__vortex__profiles_ga090a544dbe5097f9608401c405f913ff.html#ga090a544dbe5097f9608401c405f913ff">vortex_profiles_register</a>. This means, the vortex listener we are building will recognize peer wanting to create new channels based on <em>PLAIN_PROFILE</em>.</p>
<p><em><b>NOTE:</b> on connection startup every BEEP listener must report what profiles support. This allows BEEP initiators to figure out if the profile requested will be supported. Inside the Vortex Library implementation the registered profiles using <a class="el" href="group__vortex__profiles_ga090a544dbe5097f9608401c405f913ff.html#ga090a544dbe5097f9608401c405f913ff">vortex_profiles_register</a> will be used to create the supported profiles list sent to BEEP initiators.</em></p>
<p><em> The other interesting question the BEEP Core definition have is that BEEP initiators, the one which is actually connecting to a listener doesn't need to report its supported profiles. As a consequence, you can create a Vortex Client connecting to a remote server without registering a profile.</em></p>
<p><em> Obviously, this doesn't means you are not required to implement the profile. A profile is always needed by definition by both peers to know the semantic under which the messages exchange will take place.</em></p>
<p>While registering a profile, Vortex Library will allow you to register several call backs to be called on event such us channel start, channel close and frame receive during the channel's life. This event will be called (actually registered handlers) only for those channels working under the semantic of PLAIN PROFILE.</p>
<p>As a conclusion, you can have several profiles implemented, having several channels opened on the same connection <em>"running"</em> different profiles at the same time.</p>
<p>Additionally, you may require to know current connection role. This is done by using <a class="el" href="group__vortex__connection_ga0be7b3f8fe8b325900c9449c58e2ec1a.html#ga0be7b3f8fe8b325900c9449c58e2ec1a">vortex_connection_get_role</a> function. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Next, a call to <a class="el" href="group__vortex__listener_ga9745c0a637eb270f60b290efe5193352.html#ga9745c0a637eb270f60b290efe5193352">vortex_listener_new</a> creates a server listener prepared to receive connection to any name the host may have listening on port 44000. In fact, you can actually perform several calls to <a class="el" href="group__vortex__listener_ga9745c0a637eb270f60b290efe5193352.html#ga9745c0a637eb270f60b290efe5193352">vortex_listener_new</a> to listen several port at the same time.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Before previous call, it is needed to call <a class="el" href="group__vortex__listener_ga8c905a74e007c89508b3add33e595c53.html#ga8c905a74e007c89508b3add33e595c53">vortex_listener_wait</a> to block the main thread until Vortex Library is finished.</p>
<p class="endli"></p>
</li>
</ul>
<p>That's all, you have created a Vortex Server supporting a user defined profile which replies to all message received appending "Received OK: " to them. To compile it you can <a class="el" href="install.html">check out this section</a>.</p>
<h2><a class="anchor" id="profile_example_testing_server">
Testing the server created using the vortex-client tool and telnet command.</a></h2>
<p>Now, you can run the server and test it using a telnet tool to check some interesting things. The output you should get should be somewhat similar to the following:</p>
<div class="fragment"><pre class="fragment"> (jobs:1)[acinom@barbol test]
 $ ./vortex-simple-listener &amp;
 [2] 7397
 
 (jobs:2)[acinom@barbol test]
 $ telnet localhost 44000
 Trying 127.0.0.1...
 Connected to localhost.
 Escape character is <span class="stringliteral">&#39;^]&#39;</span>.
 RPY 0 0 . 0 128
 Content-Type: application/BEEP+xml
 
 &lt;greeting&gt;
    &lt;profile uri=<span class="stringliteral">&#39;http://fact.aspl.es/profiles/plain_profile&#39;</span> /&gt;
 &lt;/greeting&gt;
 END
</pre></div><p>As you can see, the server replies immediately its availability reporting the profiles it actually support. Inside the greeting element we can observe the server support the <em>PLAIN_PROFILE</em>.</p>
<p>Before starting to implement the vortex client, we can use <b>vortex-client</b> tool to check our new server. Launch the <b>vortex-client</b> tool and perform the following operations.</p>
<ul>
<li>
<p class="startli">First, connect to the server located at localhost, port 44000 using <b>vortex-client</b> tool and once connected, show supported profiles by the remote host.</p>
<div class="fragment"><pre class="fragment"> (jobs:0)[acinom@barbol libvortex-1.1]
 $ vortex-client
 Vortex-client v.0.8.3.b1498.g1498: a cmd tool to test vortex (and BEEP-enabled) peers
 Copyright (c) 2010 Advanced Software Production Line, S.L.
 [=|=] vortex-client &gt; connect
 server to connect to: localhost
 port to connect to: 44000
 connecting to localhost:44000..ok: vortex message: session established and ready
 [===] vortex-client &gt; connection status
 Created channel over <span class="keyword">this</span> session:
  channel: 0, profile: not applicable
 [===] vortex-client &gt; show profiles
 Supported remote peer profiles:
  http:<span class="comment">//fact.aspl.es/profiles/plain_profile</span>
</pre></div><p>As you can observe, <b>vortex-client</b> tool is showing we are already connected to remote peer and the connection created already have a channel created with number 0. This channel number is the BEEP administrative channel and every connection have it. This channel is used to perform special operations such as create new channels, close them and channel tuning.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Now, create a new channel choosing the plain profile as follows:</p>
<div class="fragment"><pre class="fragment"> [===] vortex-client &gt; <span class="keyword">new</span> channel
 This procedure will request to create a <span class="keyword">new</span> channel <span class="keyword">using</span> Vortex API.
 Select what profile to use to create <span class="keywordflow">for</span> the <span class="keyword">new</span> channel?
 profiles <span class="keywordflow">for</span> <span class="keyword">this</span> peer: 1
  1) http:<span class="comment">//fact.aspl.es/profiles/plain_profile</span>
  0) cancel process
 you chose: 1
 What channel number to create: you chose: 4
 creating <span class="keyword">new</span> channel..ok, channel created: 4
</pre></div> <p class="endli"></p>
</li>
<li>
<p class="startli">Now, send a test message and check if the server reply is following the implementation, that is, the message should have "Received OK: " preceding the text sent. Notify to vortex-client you want to wait for the reply.</p>
<div class="fragment"><pre class="fragment"> [===] vortex-client &gt; send message
 This procedure will send a message <span class="keyword">using</span> the vortex API.
 What channel <span class="keywordflow">do</span> you want to use to send the message? you chose: 4
 Type the message to send:
 This is a test, reply my message
 Do you want to wait <span class="keywordflow">for</span> message reply? (Y/n) y
 Message number 0 was sent..
 waiting <span class="keywordflow">for</span> reply...reply received: 
 Received Ok: This is a test, reply my message
</pre></div> <p class="endli"></p>
</li>
<li>
<p class="startli">Now, check connection status and channel status to get more data about them. This will be useful for you in the future is you want to debug BEEP peers. </p>
<div class="fragment"><pre class="fragment"> [===] vortex-client &gt; connection status
 Created channel over <span class="keyword">this</span> session:
  channel: 0, profile: not applicable
  channel: 4, profile: http:<span class="comment">//fact.aspl.es/profiles/plain_profile</span>
 [===] vortex-client &gt; channel status
 Channel number to <span class="keyword">get</span> status: 4
 Channel 4 status is: 
  Profile definition: 
     http:<span class="comment">//fact.aspl.es/profiles/plain_profile</span>
  Synchronization: 
     Last msqno sent:          0
     Next msqno to use:        1
     Last msgno received:      no message received yet
     Next reply to sent:       0
     Next reply exp. to recv:  1
     Next exp. msgno to recv:  0
     Next seqno to sent:       32
     Next seqno to receive:    45
 [===] vortex-client &gt; channel status
 Channel number to <span class="keyword">get</span> status: 0
 Channel 0 status is: 
  Profile definition: 
     not applicable
  Synchronization: 
     Last msqno sent:          0
     Next msqno to use:        1
     Last msgno received:      no message received yet
     Next reply to sent:       0
     Next reply exp. to recv:  1
     Next exp. msgno to recv:  0
     Next seqno to sent:       185
     Next seqno to receive:    228
</pre></div> <p class="endli"></p>
</li>
<li>
Close the channel created as well as the connection. <div class="fragment"><pre class="fragment"> [===] vortex-client &gt; close channel
 closing the channel..
 This procedure will close a channel <span class="keyword">using</span> the vortex API.
 What channel number to close: you chose: 4
 Channel close: ok
 [===] vortex-client &gt; close
 [=|=] vortex-client &gt; quit
</pre></div>  </li>
</ul>
<h2><a class="anchor" id="profile_example_implement_client">
Implementing a client for our server</a></h2>
<p>Now we have implemented our server supporting the <em>PLAIN PROFILE</em>, we need some code to enable us sending data.</p>
<p>The following is the client implementation which connects, creates a new channel and send a message:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;vortex.h&gt;</span>

<span class="preprocessor">#define PLAIN_PROFILE &quot;http://fact.aspl.es/profiles/plain_profile&quot;</span>
<span class="preprocessor"></span>
<span class="keywordtype">int</span>  main (<span class="keywordtype">int</span>  argc, <span class="keywordtype">char</span> ** argv)
{
        <a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection;
        <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a>    * channel;
        <a class="code" href="group__vortex__types_gac830c777ca317921af4cf7c038dcf8b7.html#gac830c777ca317921af4cf7c038dcf8b7" title="A Vortex Frame object.">VortexFrame</a>      * frame;
        <a class="code" href="group__vortex__types_ga9a57b273fb926f418b166483bfb705fc.html#ga9a57b273fb926f418b166483bfb705fc" title="Wait Reply data used for Wait Reply Method.">WaitReplyData</a>    * wait_reply;
        <a class="code" href="group__vortex__types_ga879b03a2476b60c5b9b75489aabfe7db.html#ga879b03a2476b60c5b9b75489aabfe7db" title="Vortex library context.">VortexCtx</a>        * ctx;
        <span class="keywordtype">int</span>                msg_no;

        <span class="comment">/* init vortex library */</span>
        ctx = <a class="code" href="group__vortex__ctx_gada9a1d87bfe28dd117f6d6b4356d6e31.html#gada9a1d87bfe28dd117f6d6b4356d6e31" title="Creates a new vortex execution context.">vortex_ctx_new</a> ();
        <span class="keywordflow">if</span> (! <a class="code" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280" title="Context based vortex library init.">vortex_init_ctx</a> (ctx)) {
                <span class="comment">/* unable to init vortex */</span>
                <a class="code" href="group__vortex__ctx_gad51a75c61479db09ae1619b2a8b15b7d.html#gad51a75c61479db09ae1619b2a8b15b7d" title="Releases the memory allocated by the provided VortexCtx.">vortex_ctx_free</a> (ctx);

                <span class="keywordflow">return</span> -1;
        } <span class="comment">/* end if */</span>


        <span class="comment">/* creates a new connection against localhost:44000 */</span>
        printf (<span class="stringliteral">&quot;connecting to localhost:44000...\n&quot;</span>);
        connection = <a class="code" href="group__vortex__connection_ga727b938695d1037058256e3559d9d599.html#ga727b938695d1037058256e3559d9d599" title="Allows to create a new BEEP session (connection) to the given host:port.">vortex_connection_new</a> (ctx, <span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;44000&quot;</span>, NULL, NULL);
        <span class="keywordflow">if</span> (!<a class="code" href="group__vortex__connection_ga130045a0527441a1c20332cad32f0f4d.html#ga130045a0527441a1c20332cad32f0f4d" title="Allows to get current connection status.">vortex_connection_is_ok</a> (connection, axl_false)) {
                printf (<span class="stringliteral">&quot;Unable to connect remote server, error was: %s\n&quot;</span>,
                         <a class="code" href="group__vortex__connection_ga61d4211a7519da025071c47e5dc4fedc.html#ga61d4211a7519da025071c47e5dc4fedc" title="Returns actual message status for the given connection.">vortex_connection_get_message</a> (connection));
                <span class="keywordflow">goto</span> end;
        }
        printf (<span class="stringliteral">&quot;ok\n&quot;</span>);

        <span class="comment">/* create a new channel (by chosing 0 as channel number the</span>
<span class="comment">         * Vortex Library will automatically assign the new channel</span>
<span class="comment">         * number free. */</span>
        channel = <a class="code" href="group__vortex__channel_ga4e6c15b9779b73be703ea29f5d309085.html#ga4e6c15b9779b73be703ea29f5d309085" title="Creates a new channel over the given connection.">vortex_channel_new</a> (connection, 0,
                                      PLAIN_PROFILE,
                                      <span class="comment">/* no close handling */</span>
                                      NULL, NULL,
                                      <span class="comment">/* no frame receive async</span>
<span class="comment">                                       * handling */</span>
                                      NULL, NULL,
                                      <span class="comment">/* no async channel creation */</span>
                                      NULL, NULL);
        <span class="keywordflow">if</span> (channel == NULL) {
                printf (<span class="stringliteral">&quot;Unable to create the channel..\n&quot;</span>);
                <span class="keywordflow">goto</span> end;
        }

        <span class="comment">/* create a wait reply */</span>
        wait_reply = <a class="code" href="group__vortex__channel_ga8badc3e8da1799b491b964ff937a5b5b.html#ga8badc3e8da1799b491b964ff937a5b5b" title="Creates a new wait reply to be used to wait for a specific reply.">vortex_channel_create_wait_reply</a> ();
     
        <span class="comment">/* now send the message using msg_and_wait/v */</span>
        <span class="keywordflow">if</span> (!<a class="code" href="group__vortex__channel_gae586179d47efee5d0fc9bd34e6f2521a.html#gae586179d47efee5d0fc9bd34e6f2521a" title="Allows to send a message and start a wait reply.">vortex_channel_send_msg_and_wait</a> (channel, <span class="stringliteral">&quot;my message&quot;</span>, strlen (<span class="stringliteral">&quot;my message&quot;</span>), &amp;msg_no, wait_reply)) {
                printf (<span class="stringliteral">&quot;Unable to send my message\n&quot;</span>);
                <a class="code" href="group__vortex__channel_ga9ad0ef43364b7211d96e8ed703f19fa3.html#ga9ad0ef43364b7211d96e8ed703f19fa3" title="Terminates allocated memory by wait reply data.">vortex_channel_free_wait_reply</a> (wait_reply);
                <a class="code" href="group__vortex__channel_gac355276dbcfb7b95eb074d55292a6e3e.html#gac355276dbcfb7b95eb074d55292a6e3e" title="Close the given channel.">vortex_channel_close</a> (channel, NULL);
                <span class="keywordflow">goto</span> end;
                
        }

        <span class="comment">/* get blocked until the reply arrives, the wait_reply object</span>
<span class="comment">         * must not be freed after this function because it already</span>
<span class="comment">         * free it. */</span>
        frame = <a class="code" href="group__vortex__channel_gab82ec2ad83aa8845fcaf4a24c9b17b75.html#gab82ec2ad83aa8845fcaf4a24c9b17b75" title="Allows caller to wait for a particular reply to be received.">vortex_channel_wait_reply</a> (channel, msg_no, wait_reply);
        <span class="keywordflow">if</span> (frame == NULL) {
                printf (<span class="stringliteral">&quot;there was an error while receiving the reply or a timeout have occur\n&quot;</span>);
                <a class="code" href="group__vortex__channel_gac355276dbcfb7b95eb074d55292a6e3e.html#gac355276dbcfb7b95eb074d55292a6e3e" title="Close the given channel.">vortex_channel_close</a> (channel, NULL);
                <span class="keywordflow">goto</span> end;
        }
        printf (<span class="stringliteral">&quot;my reply have arrived: (size: %d):\n%s\n&quot;</span>, 
                <a class="code" href="group__vortex__frame_gab375e839af5bcef9556f43fcf5875b18.html#gab375e839af5bcef9556f43fcf5875b18" title="Returns the current payload size the given frame have without taking into account...">vortex_frame_get_payload_size</a> (frame), 
                (<span class="keywordtype">char</span>*) <a class="code" href="group__vortex__frame_ga2ac165d800ebaca853c7a2634e5c6de4.html#ga2ac165d800ebaca853c7a2634e5c6de4" title="Returns the payload associated to the given frame.">vortex_frame_get_payload</a> (frame));

 end:                                 
        <a class="code" href="group__vortex__connection_gaa2cfa2eb776f65ce6805247f53cc1067.html#gaa2cfa2eb776f65ce6805247f53cc1067" title="Tries to close properly a connection and all channels inside it.">vortex_connection_close</a> (connection);

        <span class="comment">/* terminate execution context */</span>
        <a class="code" href="group__vortex_ga755d3c8fb55979c25c5abb1ab3939faa.html#ga755d3c8fb55979c25c5abb1ab3939faa" title="Terminates the vortex library execution on the provided context.">vortex_exit_ctx</a> (ctx, axl_false);

        <span class="comment">/* free ctx */</span>
        <a class="code" href="group__vortex__ctx_gad51a75c61479db09ae1619b2a8b15b7d.html#gad51a75c61479db09ae1619b2a8b15b7d" title="Releases the memory allocated by the provided VortexCtx.">vortex_ctx_free</a> (ctx);

        <span class="keywordflow">return</span> 0 ;            
}


</pre></div><p>As you can observe the client is somewhat more complicated than the server because it has to create not only the connection but also the channel, sending the message and use the wait reply method to read remote server reply.</p>
<p>Due to the test nature, we have used wait reply method so the test code gets linear in the sense <em>"I send the message and I get blocked
 until the reply is received"</em> but this is not the preferred method.</p>
<p>The Vortex Library preferred method is to install a frame receive handler and receive data replies or new message in an asynchronous way. But, doing this on this example maybe will produce to increase the complexity. If you want to know more about receiving data using other methods, check this <a class="el" href="starting__to__program.html#vortex_manual_dispatch_schema">section</a> to know more about how can data is received.</p>
<h2><a class="anchor" id="profile_example_conclusion">
Conclusion</a></h2>
<p>We have seen how to create not only a profile but also a simple Vortex Server and a Vortex Client.</p>
<p>We have also seen how we can use <b>vortex-client</b> tool to test and perform operations against BEEP enabled peers in general and against Vortex Library peers in particular.</p>
<p>We have also talked about the administrative channel: the channel 0. This channel is present on every connection established and it is used for special operations about channel management.</p>
<p>In fact, the channel 0 is running under the definition of a profile defined at the RFC 3080 called <em>Channel Management Profile</em>. This is another example on how profiles are implemented: they only are definitions that must be implemented in order BEEP peers could notify others that they actually support it. In this case, *the <em>Channel Profile Management</em> is mandatory.</p>
<p>As another example for the previous point is the <b>Coyote Layer</b> inside the Af-Arch project. Coyote layer implements the profile:</p>
<div class="fragment"><pre class="fragment">  http:<span class="comment">//fact.aspl.es/profiles/coyote_profile</span>
</pre></div><p>On Af-Arch project, remote procedure invocation is done through a XML-RPC like message exchange defined and implemented at the Coyote layer (which is not XML-RPC defined at RFC3529).</p>
<p>If upper levels want to send a message to a remote Af-Arch enabled node, they do it through the Coyote layer. Coyote layer takes the message and transform it into a <b>coyote_profile</b> compliant message so remote peer, running also a Coyote layer, can recognize it.</p>
<p>In other words, the profile is registered using <a class="el" href="group__vortex__profiles_ga090a544dbe5097f9608401c405f913ff.html#ga090a544dbe5097f9608401c405f913ff">vortex_profiles_register</a> and implemented on top of the Vortex Library. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="lateral-ad">
  <iframe src="http://www.aspl.es/web-ads/index.php?hcolor=fdff4f&amp;fsize=10&amp;bg=555753&amp;fg=ffffff&amp;width=150&amp;type=vertical" height="420" align="middle" width="100%" scrolling="no" frameborder="0"></iframe>
</div>
<div class="footer">
<small>Vortex Library:  A BEEP (RFC3080/RFC3081) implementation. &nbsp; Copyright 2008 (C) Advanced Software Production Line, S.L.</small>
</div>
</body>
</html>

