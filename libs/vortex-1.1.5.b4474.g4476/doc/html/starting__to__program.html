<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>Vortex Library, BEEP Core implementation, RFC 3080 / RFC 3081, XML-RPC, XML-RPC over BEEP, RFC 3529, BEEP Framework, BEEP protocol, BEEP, BEEP library, BEEP libraries, beepcore (Servidores Linux http://www.aspl.es)</title>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-123192-2";
urchinTracker();
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="vortex.css" rel="stylesheet" type="text/css">
</head>
  <body>
    <div class="af-arch-header">
     <img src="main-page-logo.png" > <a href="http://www.aspl.es"><img class="aspl-logo-header" src="aspl-logo-header.png"></a>
    </div>
    <div class="ads">
    <iframe src="http://www.aspl.es/web-ads/index.php?hcolor=fdff4f&amp;fsize=10&amp;bg=555753&amp;fg=ffffff&amp;width=800&amp;height=90" scrolling="no" frameborder="0"></iframe> 
    </div>
    <div class="separator">
    </div>
<div class="thepage">

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="starting_to_program">Vortex Library Manual (C API) </a></h1><h2><a class="anchor" id="Introduction">
Introduction</a></h2>
<p>On this manual you will find the following sections:</p>
<p><b>Section 1: </b>An introduction to BEEP and Vortex Library</p>
<ul>
<li><a class="el" href="starting__to__program.html#vortex_manual_concepts">1.1 Some concepts before starting to use Vortex</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_listener">1.2 How a Vortex Listener works (or how to create one)</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_client">1.3 How a vortex client works (or how to create a connection)</a></li>
</ul>
<p><b>Section 2: </b>Sending and receiving data with Vortex Library</p>
<ul>
<li><a class="el" href="starting__to__program.html#vortex_manual_sending_frames">2.1 How an application must use Vortex Library to send and receive data</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_dispatch_schema">2.2 The Vortex Library Frame receiving dispatch schema (or how incoming frames are read)</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_printf_like">2.3 Printf like interface while sending messages and replies</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_wait_reply">2.4 Sending data and wait for a specific reply (or how get blocked until a reply arrives)</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_invocation_chain">2.5 Invocation level for frames receive handler</a></li>
</ul>
<p><b>Section 3: </b>Doing Vortex Library to work like you expect: profiles, internal configuration and other useful information to adapt Vortex Library to your needs.</p>
<ul>
<li><a class="el" href="starting__to__program.html#vortex_manual_profiles">3.1 Defining a profile inside Vortex (or How profiles concept confuse people)</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_implementing_request_response_pattern">3.2 Implementing the request-response pattern</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_changing_vortex_io">3.3 Configuring Vortex Library IO layer</a></li>
</ul>
<p><b>Section 4: </b>Advanced topics</p>
<ul>
<li><a class="el" href="starting__to__program.html#vortex_manual_piggyback_support">4.1 Using piggyback to save one round trip at channel startup</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_using_mime">4.2 Using MIME configuration for data exchanged under Vortex Library</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_transfering_files">4.3 General considerations about transfering files</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_http_support">4.4 Doing BEEP connections through HTTP proxy servers</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_pull_api">4.5 PULL API single thread event notification</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_alive_api">4.6 ALIVE API, active checks for connection status</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_feeder_api">4.7 How to use feeder API (streaming and transfering files efficiently)</a></li>
</ul>
<p><b>Section 5: </b>Securing and authenticating your BEEP sessions: TLS and SASL profiles</p>
<ul>
<li><a class="el" href="starting__to__program.html#vortex_manual_securing_your_session">5.1 Securing a Vortex Connection (or How to use the TLS profile)</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_creating_certificates">5.2 How to create a test certificate and a private key to be used by the TLS profile</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_using_sasl">5.3 Authenticating BEEP peers (or How to use SASL profiles family)</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_sasl_for_client_side">5.4 How to use SASL at the client side</a></li>
<li><a class="el" href="starting__to__program.html#vortex_manual_sasl_for_server_side">5.5 How to use SASL at the server side</a></li>
</ul>
<h2><a class="anchor" id="vortex_manual_concepts">
1.1 Some concepts before starting to use Vortex</a></h2>
<p>Before beginning, we have to review some definitions about the protocol that <b>Vortex Library</b> implements. This will help you to understand why Vortex Library uses some names to refer things such as: <b>frames, channels, profiles</b>, etc.</p>
<p><b>Vortex Library is an implementation of the RFC 3080/RFC 3081 protocol</b>, also known as <b>BEEP: Block Extensible Exchange Protocol</b>. In the past it was called BXXP because the Xs of e(X)tensible and e(X)change. Due to some marketing naming decision finally it was called BEEP because the Es of the (E)xtensible and (E)xchange.</p>
<div class="fragment"><pre class="fragment">    BEEP:   the protocol
    Vortex: an implementation
</pre></div><p>From a simple point of view, the <a href="http://www.beepcore.org">BEEP protocol</a> defines how data must be exchanged between applications, also called BEEP peers, using several abstractions, that allows programmers to write network applications with stronger features such as asynchronous communication, several concurrent messages being exchanged over the same connection and so on, without worrying too much about details.</p>
<p>Previous abstractions defined by the BEEP RFC are really important. To understand them is a key to understand, not only BEEP as a protocol but Vortex Library as an implementation. This will also help you to get better results while using BEEP to implement your network protocol.</p>
<div class="fragment"><pre class="fragment">       BEEP abstraction layer
       -----------------------
       |       Message       |
       -----------------------
       |        Frame        |
       |                     |
       |      (payload)      |
       -----------------------
       |  Channel / Profiles |
       -----------------------
       |       Session       |
       -----------------------
</pre></div><p>Previous table <b>is not the BEEP API stack</b> or the <b>Vortex Library API stack</b>. It represents the concepts you must use to be able to send and receive data while using a <b>BEEP</b> implementation like Vortex Library.</p>
<p>A <b>message is actually your application data</b> to be sent to a remote peer. It has no special meaning for a <b>BEEP</b> implementation. Applications using the particular BEEP implementation are the ones who finally pay attention to message format, correction and content meaning.</p>
<p>When you send a message (or a reply) <b>these messages could be splitted into frames</b>.</p>
<p>These frames have an special header, called the BEEP frame header, which includes information about payload sequence, message type, channels used and many things more. This data, included inside the BEEP frame headers allows BEEP peers to track communication status, making it possible to detect errors, sync lost, etc.</p>
<p><b>Payload</b> is the way network protocol designers usually call to the application level data, that is, your data application. However, this payload could represent only a piece of your information. This is not important for you, at this moment, because <b>Vortex Library</b> manage frame fragmentation (internal/external) in a transparent way.</p>
<p>When <b>you send a message, you select a channel to do this communication</b>. We have seen that a message is actually splitted but from the application view, in most cases, this is not important: <b>applications send messages over channels</b>.</p>
<p>Inside <a href="http://www.beepcore.org">BEEP protocol</a>, <b>every channel created</b> must be running <b>under the semantic of a profile definition</b>. In fact, the part of the application that takes care about message format, correction, and content meaning is the BEEP profile.</p>
<p>This simple concept, which usually confuse programmers new to BEEP, is not anything estrange or special. A profile <b>only defines what type of messages will be exchanged</b> inside a channel. It is just an agreement between BEEP peers about the messages to exchange inside a channel and what they mean.</p>
<p>Actually, <b>to support a profile</b> means to register the string which identifies the profile and to implement it on top of Vortex Library so that profile can send and receive message according to the format the profile defines. <b>A profile inside Vortex Library is not</b>:</p>
<ul>
<li>A dll you have to implement or a plug in to be attached. It is a piece of code written on top of the library.</li>
</ul>
<ul>
<li>This only applies to Vortex Library. If you use Turbulence (<a href="http://www.turbulence.ws">http://www.turbulence.ws</a>) you'll find that is allows to write new BEEP profiles as plugins, but you still write code calling to the Vortex Library API.</li>
</ul>
<p>In order to use the Vortex Library, and any BEEP implementation, you must define your own profile. Later, you can read: <a class="el" href="starting__to__program.html#vortex_manual_profiles">defining a profile inside Vortex Library</a>.</p>
<p>The last one concept to understand is <b>the BEEP session</b>. According to BEEP RFC, a session is an abstraction which allows to hold all channels created to a remote BEEP peer (no matter what profiles where used). Because Vortex Library is a BEEP implementation mapped into TCP/IP, a session is actually a TCP connection (with some additional data).</p>
<p>Now we know most of the concepts involving BEEP, here goes how these concepts get mapped into a concrete example using Vortex. Keep in mind this is a simplified version on how Vortex Library could be.</p>
<p>We we have to do first, is to create a context. This object will be used by your application to keep the state and the current configuration. This is done as follow:</p>
<div class="fragment"><pre class="fragment">       <a class="code" href="group__vortex__types_ga879b03a2476b60c5b9b75489aabfe7db.html#ga879b03a2476b60c5b9b75489aabfe7db" title="Vortex library context.">VortexCtx</a> * ctx;

       <span class="comment">// create an empty context </span>
       ctx = <a class="code" href="group__vortex__ctx_gada9a1d87bfe28dd117f6d6b4356d6e31.html#gada9a1d87bfe28dd117f6d6b4356d6e31" title="Creates a new vortex execution context.">vortex_ctx_new</a> ();

       <span class="comment">// do your required configuration here</span>

       <span class="comment">// init the context and start vortex library execution </span>
       <span class="keywordflow">if</span> (! <a class="code" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280" title="Context based vortex library init.">vortex_init_ctx</a> (ctx)) {
                <span class="comment">// handle error </span>
              <span class="keywordflow">return</span> -1;
       }
</pre></div><p>In order to send a message to a remote peer you'll have to create a <a class="el" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4">VortexConnection</a>, using <a class="el" href="group__vortex__connection_ga727b938695d1037058256e3559d9d599.html#ga727b938695d1037058256e3559d9d599">vortex_connection_new</a> as follows:</p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">char</span>  * host = <span class="stringliteral">&quot;myhost.at.frobnicate.com&quot;</span>;
        <span class="keywordtype">char</span>  * port = <span class="stringliteral">&quot;55000&quot;</span>;
 
        <span class="comment">// Creates a Vortex Connection without providing a</span>
        <span class="comment">// OnConnected handler or user data. This will block us</span>
        <span class="comment">// until the connection is created or fails.</span>
        <a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection = <a class="code" href="group__vortex__connection_ga727b938695d1037058256e3559d9d599.html#ga727b938695d1037058256e3559d9d599" title="Allows to create a new BEEP session (connection) to the given host:port.">vortex_connection_new</a> (ctx, host, port, NULL, NULL);
</pre></div><p>Once finished, you have actually created a BEEP session. Then you have to create a <a class="el" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f">VortexChannel</a>, using <a class="el" href="group__vortex__channel_ga4e6c15b9779b73be703ea29f5d309085.html#ga4e6c15b9779b73be703ea29f5d309085">vortex_channel_new</a> function, providing a profile defined by you or an existing one. On that process it is needed to select the channel number, let's say we want to create the channel 2.</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// Create a Vortex Channel over the given connection and using as channel number: 2.</span>
        <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a> * new_channel = NULL;
        new_channel = <a class="code" href="group__vortex__channel_ga4e6c15b9779b73be703ea29f5d309085.html#ga4e6c15b9779b73be703ea29f5d309085" title="Creates a new channel over the given connection.">vortex_channel_new</a> (connection, 2,
                                          <span class="stringliteral">&quot;http://my.profile.com&quot;</span>,
                                          <span class="comment">// do not provide on</span>
                                          <span class="comment">// channel close handlers.</span>
                                          NULL, NULL, 
                                          <span class="comment">// provide frame receive</span>
                                          <span class="comment">// handler (second level one)</span>
                                          <span class="comment">// Now, on_receiving_data</span>
                                          <span class="comment">// will be executed for every</span>
                                          <span class="comment">// frame received on this</span>
                                          <span class="comment">// channel unless wait reply</span>
                                          <span class="comment">// method is used.</span>
                                          on_receiving_data, NULL,
                                          <span class="comment">// do not provide a</span>
                                          <span class="comment">// OnChannelCreated</span>
                                          <span class="comment">// handler. This will block</span>
                                          <span class="comment">// us until the channel is</span>
                                          <span class="comment">// created.</span>
                                          NULL, NULL);
</pre></div><p>Once the channel is created (keep in mind that the remote peer can actually deny the channel creation) you could send messages to remote peer using this channel as follows:</p>
<div class="fragment"><pre class="fragment">       <span class="comment">// send a reply import message to remote peer.</span>
       <span class="keywordflow">if</span> (<a class="code" href="group__vortex__channel_ga69167b79eaca52375ced805c13125cd8.html#ga69167b79eaca52375ced805c13125cd8" title="Sends the message over the selected channel.">vortex_channel_send_msg</a> (new_channel,
                                   <span class="stringliteral">&quot;this a message to be sent&quot;</span>,
                                   25,
                                   NULL)) {
           printf (<span class="stringliteral">&quot;Okey, my message was sent&quot;</span>);
       }
</pre></div><p>And finally, once the channel is no longer needed, you can close it as follows:</p>
<div class="fragment"><pre class="fragment">      <span class="comment">// close the channel. This will block us until the channel is closed because</span>
      <span class="comment">// to close a channel can actually take longer time because the remote peer</span>
      <span class="comment">// may not accept close request until he is done.</span>
      <span class="keywordflow">if</span> (<a class="code" href="group__vortex__channel_gac355276dbcfb7b95eb074d55292a6e3e.html#gac355276dbcfb7b95eb074d55292a6e3e" title="Close the given channel.">vortex_channel_close</a> (new_channel, NULL)) {
           printf (<span class="stringliteral">&quot;Okey, my channel have been closed&quot;</span>);
      }

      <span class="comment">// finally, terminate vortex context execution running</span>
      <a class="code" href="group__vortex_ga755d3c8fb55979c25c5abb1ab3939faa.html#ga755d3c8fb55979c25c5abb1ab3939faa" title="Terminates the vortex library execution on the provided context.">vortex_exit_ctx</a> (ctx, axl_true);
</pre></div><p>That's all. You have created a simple Vortex Library client that have connected, created a channel, send a message, close the channel and terminated Vortex Library function.</p>
<h2><a class="anchor" id="vortex_manual_listener">
1.2 How a Vortex Listener works (or how to create one)</a></h2>
<p>To create a vortex listener, which waits for incoming beep connection on a given port the following must be done:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &lt;vortex.h&gt;</span>

   <span class="comment">// vortex global context </span>
   <a class="code" href="group__vortex__types_ga879b03a2476b60c5b9b75489aabfe7db.html#ga879b03a2476b60c5b9b75489aabfe7db" title="Vortex library context.">VortexCtx</a> * ctx = NULL;

   <span class="keywordtype">void</span> on_ready (<span class="keywordtype">char</span>  * host, <span class="keywordtype">int</span>  port, <a class="code" href="group__vortex__types_ga25d85d2d28e8808a03b003e13c452e17.html#ga25d85d2d28e8808a03b003e13c452e17" title="Vortex Operation Status.">VortexStatus</a> status,
                  <span class="keywordtype">char</span>  * message, axlPointer user_data) {
        <span class="keywordflow">if</span> (status != <a class="code" href="group__vortex__types_ga25d85d2d28e8808a03b003e13c452e17.html#gga25d85d2d28e8808a03b003e13c452e17aa6d3a6595c96e728ca3cd55164407fb6" title="Represents the operation have been successfully completed.">VortexOk</a>) {
              printf (<span class="stringliteral">&quot;Unable to initialize vortex listener: %s\n&quot;</span>, message);
              <span class="comment">// do not exit from here using: exit or vortex_exit. This is actually</span>
              <span class="comment">// done by the main thread</span>
        }
        printf (<span class="stringliteral">&quot;My vortex server is up and ready..\n&quot;</span>);
        <span class="comment">// do some stuff..</span>
   }

   <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span>  argc, <span class="keywordtype">char</span>  ** argv) {

       <span class="comment">// create an empty context </span>
       ctx = <a class="code" href="group__vortex__ctx_gada9a1d87bfe28dd117f6d6b4356d6e31.html#gada9a1d87bfe28dd117f6d6b4356d6e31" title="Creates a new vortex execution context.">vortex_ctx_new</a> ();

       <span class="comment">// init the context</span>
       <span class="keywordflow">if</span> (! <a class="code" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280" title="Context based vortex library init.">vortex_init_ctx</a> (ctx)) {
           printf (<span class="stringliteral">&quot;failed to init the library..\n&quot;</span>);
       } 

       <span class="comment">// register a profile</span>
       <a class="code" href="group__vortex__profiles_ga090a544dbe5097f9608401c405f913ff.html#ga090a544dbe5097f9608401c405f913ff" title="Allows to register a new profile inside the Vortex Library.">vortex_profiles_register</a> (ctx, SOME_PROFILE_URI, 
                                 <span class="comment">// provide a first level start</span>
                                 <span class="comment">// handler (start handler can only be</span>
                                 <span class="comment">// provided at first level)</span>
                                 start_handler, start_data, 
                                 <span class="comment">// provide a first level close handler</span>
                                 close_handler, close_data,
                                 <span class="comment">// provide a first level frame receive handler</span>
                                 frame_received_handler, frame_received_data);
 
       <span class="comment">// create a vortex server using any name the running host may have.</span>
       <span class="comment">// the on_ready handler will be executed on vortex listener creation finish.</span>
       <a class="code" href="group__vortex__listener_ga9745c0a637eb270f60b290efe5193352.html#ga9745c0a637eb270f60b290efe5193352" title="Creates a new Vortex Listener accepting incoming connections on the given host:port...">vortex_listener_new</a> (ctx, <span class="stringliteral">&quot;0.0.0.0&quot;</span>, <span class="stringliteral">&quot;44000&quot;</span>, on_ready);
 
       <span class="comment">// wait for listeners</span>
       <a class="code" href="group__vortex__listener_ga8c905a74e007c89508b3add33e595c53.html#ga8c905a74e007c89508b3add33e595c53" title="Blocks a listener (or listeners) launched until vortex finish.">vortex_listener_wait</a> (ctx);

       <span class="comment">// finalize vortex running</span>
       <a class="code" href="group__vortex_ga755d3c8fb55979c25c5abb1ab3939faa.html#ga755d3c8fb55979c25c5abb1ab3939faa" title="Terminates the vortex library execution on the provided context.">vortex_exit_ctx</a> (ctx, axl_false);

        <span class="keywordflow">return</span> 0;
   }
</pre></div><p>These four steps does the follow: </p>
<ul>
<li>
<p class="startli">Initialize the library and its subsystems using <a class="el" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280">vortex_init_ctx</a>. If <a class="el" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280">vortex_init_ctx</a> function is not called, unexpected behaviors will happen.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Register one (or more profiles) the listener being created will accept as valid profiles to create new channels over session using <a class="el" href="group__vortex__profiles_ga090a544dbe5097f9608401c405f913ff.html#ga090a544dbe5097f9608401c405f913ff">vortex_profiles_register</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create the listener using <a class="el" href="group__vortex__listener_ga9745c0a637eb270f60b290efe5193352.html#ga9745c0a637eb270f60b290efe5193352">vortex_listener_new</a>, specifying the hostname to be used to listen incoming connection and the port. If hostname used is 0.0.0.0 all hostname found will be used. If 0 is used as port, an automatic port assigned by the SO will be used.</p>
<p class="endli"></p>
</li>
<li>
Finally, call to wait listener created using <a class="el" href="group__vortex__listener_ga8c905a74e007c89508b3add33e595c53.html#ga8c905a74e007c89508b3add33e595c53">vortex_listener_wait</a>. </li>
</ul>
<p>On the 2) step, which register a profile called SOME_PROFILE_URI to be used on channel creation, it also set handlers to be called on events happening for this listener.</p>
<p>These handlers are: <b>start handler</b>, <b>close handler</b>, and <b>frame_received</b> handler.</p>
<p>The <a class="el" href="group__vortex__handlers_ga80c00e4df48fb1740c5946bbdeea7d90.html#ga80c00e4df48fb1740c5946bbdeea7d90">start handler</a> is executed to notify that a new petition to create a new channel over some session have arrived. But this handler is also executed to know if Vortex Listener agree to create the channel. If start handler returns axl_true the channel will be created, otherwise not.</p>
<p>If you don't define a start handler a default one will be used which always returns axl_true. This means: all channel creation petition will be accepted.</p>
<p>The <a class="el" href="group__vortex__handlers_ga80a1b36b5894abf6b39054d7f4b16b98.html#ga80a1b36b5894abf6b39054d7f4b16b98">close handler</a> works the same as start handler but this time to notify if a channel can be closed. Again, if close handler returns axl_true, the channel will be closed, otherwise not.</p>
<p>If you don't provide a close handler, a default one will be used, which always returns axl_true, that is, all channel close petition will be accepted.</p>
<p>The <a class="el" href="group__vortex__handlers_ga9b856fd8f489ea778799e610eaa0e619.html#ga9b856fd8f489ea778799e610eaa0e619">frame received handler</a> is executed to notify a new frame have arrived over a particular channel. The frame before been delivered, have been verified to be properly defined. But, payload content must be actually checked by the profile implementation. Vortex Library doesn't pay attention to the payload actually being transported by frames.</p>
<p>All notification are run on newly created threads, that are already created threads inside a thread pool.</p>
<p>As a test, you can run the server defined above, and use the <b>vortex-client</b> tool to check it.</p>
<h2><a class="anchor" id="vortex_manual_client">
1.3 How a vortex client works (or how to create a connection)</a></h2>
<p>A vortex client peer works in a different way than listener does. In order to connect to a vortex listener server (or a BEEP enabled peer) a vortex client peer have to:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &lt;vortex.h&gt;</span>
   
   <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span>  argc, <span class="keywordtype">char</span>  ** argv) {
     <span class="comment">// a connection reference </span>
     <a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection;
     <a class="code" href="group__vortex__types_ga879b03a2476b60c5b9b75489aabfe7db.html#ga879b03a2476b60c5b9b75489aabfe7db" title="Vortex library context.">VortexCtx</a>        * ctx;

     <span class="comment">// create an empty context </span>
     ctx = <a class="code" href="group__vortex__ctx_gada9a1d87bfe28dd117f6d6b4356d6e31.html#gada9a1d87bfe28dd117f6d6b4356d6e31" title="Creates a new vortex execution context.">vortex_ctx_new</a> ();

     <span class="comment">// init the context</span>
     <span class="keywordflow">if</span> (! <a class="code" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280" title="Context based vortex library init.">vortex_init_ctx</a> (ctx)) {
           printf (<span class="stringliteral">&quot;failed to init the library..\n&quot;</span>);
     } 
 
     <span class="comment">// connect to remote vortex listener</span>
     connection = <a class="code" href="group__vortex__connection_ga727b938695d1037058256e3559d9d599.html#ga727b938695d1037058256e3559d9d599" title="Allows to create a new BEEP session (connection) to the given host:port.">vortex_connection_new</a> (ctx, host, port, 
                                         <span class="comment">// do not provide an on_connected_handler </span>
                                         NULL, NULL);
 
     <span class="comment">// check if everything is ok</span>
     <span class="keywordflow">if</span> (!<a class="code" href="group__vortex__connection_ga130045a0527441a1c20332cad32f0f4d.html#ga130045a0527441a1c20332cad32f0f4d" title="Allows to get current connection status.">vortex_connection_is_ok</a> (connection, axl_false)) {
            printf (<span class="stringliteral">&quot;Connection have failed: %s\n&quot;</span>, 
                    <a class="code" href="group__vortex__connection_ga61d4211a7519da025071c47e5dc4fedc.html#ga61d4211a7519da025071c47e5dc4fedc" title="Returns actual message status for the given connection.">vortex_connection_get_message</a> (connection));
            <a class="code" href="group__vortex__connection_gaa2cfa2eb776f65ce6805247f53cc1067.html#gaa2cfa2eb776f65ce6805247f53cc1067" title="Tries to close properly a connection and all channels inside it.">vortex_connection_close</a> (connection);
     }
   
     <span class="comment">// connection ok, do some stuff</span>
     

     <span class="comment">// and finally call to terminate vortex</span>
     <a class="code" href="group__vortex_ga755d3c8fb55979c25c5abb1ab3939faa.html#ga755d3c8fb55979c25c5abb1ab3939faa" title="Terminates the vortex library execution on the provided context.">vortex_exit_ctx</a> (ctx, axl_true);
   }
</pre></div><p>Previous steps stands for: </p>
<ul>
<li>
<p class="startli">Initialize Vortex Library calling to <a class="el" href="group__vortex_ga3f5c9f2cc368c38589d0ab24ed909280.html#ga3f5c9f2cc368c38589d0ab24ed909280">vortex_init_ctx</a>. As we have seen on vortex listener case, if vortex library is not initialized unexpected behaviors will occur.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Connect to remote peer located at host and port using <a class="el" href="group__vortex__connection_ga727b938695d1037058256e3559d9d599.html#ga727b938695d1037058256e3559d9d599">vortex_connection_new</a>. This function will create a BEEP session (actually a connection with some additional info) to remote site.</p>
<p>This function will block the caller until connection is created because the example didn't provide an <a class="el" href="group__vortex__handlers_ga122c5763b38fd5c44f205d87d866d0a5.html#ga122c5763b38fd5c44f205d87d866d0a5">on_connected_handler</a> function (that is, passing a NULL value).</p>
<p>This makes code easy to understand, because it is linear to read but, using it on graphical user interfaces turns out that it is not a good option. If you provide a <a class="el" href="group__vortex__handlers_ga122c5763b38fd5c44f205d87d866d0a5.html#ga122c5763b38fd5c44f205d87d866d0a5">on_connected_handler</a> the function will not block the caller and will do the connection process in a separated thread.</p>
<p>Once the connection process have been finished vortex library will notify on the defined handler allowing caller thread to keep on doing other stuff such updating the user interface with some cute connection progress bar.</p>
<p>This initial connection creates not only a BEEP session, it also creates the channel 0. This channel is used for session management functions such as channel creation. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Finally, returned connection must be checked using <a class="el" href="group__vortex__connection_ga130045a0527441a1c20332cad32f0f4d.html#ga130045a0527441a1c20332cad32f0f4d">vortex_connection_is_ok</a>. This step must be done on both model: on block model and on threaded model.</p>
<p class="endli"></p>
</li>
</ul>
<p>Once a vortex connection is successfully completed, it is registered on Vortex Reader thread. This allows Vortex Reader thread to process and dispatch all incoming frame to its default channel handler.</p>
<p>We have talked about channel handlers: the <a class="el" href="group__vortex__handlers_ga80c00e4df48fb1740c5946bbdeea7d90.html#ga80c00e4df48fb1740c5946bbdeea7d90">start</a>, <a class="el" href="group__vortex__handlers_ga80a1b36b5894abf6b39054d7f4b16b98.html#ga80a1b36b5894abf6b39054d7f4b16b98">close</a> and <a class="el" href="group__vortex__handlers_ga9b856fd8f489ea778799e610eaa0e619.html#ga9b856fd8f489ea778799e610eaa0e619">frame received</a> handler. Due to client peer nature, it will be common to not pay attention to start and close events. If no handler is defined, default ones will be used. Of course, if it is needed to have more control over this process, event handlers should be defined.</p>
<p>The <a class="el" href="group__vortex__handlers_ga9b856fd8f489ea778799e610eaa0e619.html#ga9b856fd8f489ea778799e610eaa0e619">frame received</a> handler must be defined for each channel created. If no frame received handler is defined for a channel used by a vortex client, virtually you won't receive any frame.</p>
<p>This is because a vortex client is not required to register a profile before creating Vortex Connections. Of course, if you register a profile with the handlers before creating the connection those ones will be used if not handlers are provided on channel creation. See <a class="el" href="starting__to__program.html#vortex_manual_dispatch_schema">this section</a> to understand how the frame dispatch schema works.</p>
<h2><a class="anchor" id="vortex_manual_sending_frames">
2.1 How an application must use Vortex Library to send and receive data</a></h2>
<p>As defined on RFC 3080, any BEEP enabled application should define a profile to be used for its message exchange. That profile will make a decision about which message-exchange style defined will use. There are 3 message exchange style.</p>
<ul>
<li>
<p class="startli"><b>MSG/RPY</b>: this is a one-to-one message exchange style and means a BEEP peer sends a message MSG and remote peer perform some task to finally responds using a RPY message type.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>MSG/ERR</b>: this is a one-to-one message exchange style and means the same as previous message exchange but remote peer have responded with an error, so the task was not performed.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>MSG/ANS</b>: this is a one-to-many message exchange style and works pretty much as MSG/RPY definition but defined to allows remote peer to keep on send ANS frames during the task execution. This type of message exchange replies to a MSG received with several ANS replies, with no constrains about the limit of ANS to be sent, ending that reply series with a NUL frame.</p>
<p class="endli"></p>
</li>
</ul>
<p>While using Vortex Library you can send data to remote peer using the following functions defined at the vortex channel API.</p>
<div class="fragment"><pre class="fragment"> 1) <a class="code" href="group__vortex__channel_ga69167b79eaca52375ced805c13125cd8.html#ga69167b79eaca52375ced805c13125cd8" title="Sends the message over the selected channel.">vortex_channel_send_msg</a>
 
 2) <a class="code" href="group__vortex__channel_gaf45dc7a82e996b3f19d1252258fcd42f.html#gaf45dc7a82e996b3f19d1252258fcd42f" title="Allows to send a message reply using RPY type.">vortex_channel_send_rpy</a>
 
 3) <a class="code" href="group__vortex__channel_ga3ef260bc9f143b8bb13df7ddf79cf0ea.html#ga3ef260bc9f143b8bb13df7ddf79cf0ea" title="Allows to reply a message using ERR message type.">vortex_channel_send_err</a>
 
 4) <a class="code" href="group__vortex__channel_ga6c2e3867ab784a80a46462db4083e03e.html#ga6c2e3867ab784a80a46462db4083e03e" title="Allows to perform an ANS/NUL reply to a given MSG frame received.">vortex_channel_send_ans_rpy</a>
</pre></div><p>As you may observe to generate the different types of message to be sent a function is provided:</p>
<p>The first one allows you to send a new message. Once the message is queued to be sent the function returns you the message number used for this sending attempt. This function never block and actually do not send the message directly. It just signal the Vortex Sequencer to do the frame sequencing which finally will make Vortex Writer to send the frames generated.</p>
<p>The second function allows to positive reply to a specific message received. In order to be able to perform a positive reply using <a class="el" href="group__vortex__channel_gaf45dc7a82e996b3f19d1252258fcd42f.html#gaf45dc7a82e996b3f19d1252258fcd42f">vortex_channel_send_rpy</a> or a negative reply using <a class="el" href="group__vortex__channel_ga3ef260bc9f143b8bb13df7ddf79cf0ea.html#ga3ef260bc9f143b8bb13df7ddf79cf0ea">vortex_channel_send_err</a> you have to provide the message number to reply to.</p>
<p>The third function allows to reply an error to a specify message received. As the previous function it is needed the message number to reply to.</p>
<p>The fourth function allows to reply an ANS message to a received MSG. Several calls to that send ANS replies must be always ended with <a class="el" href="group__vortex__channel_gacdc7aa1340de601f1301598b2bdeb194.html#gacdc7aa1340de601f1301598b2bdeb194">vortex_channel_finalize_ans_rpy</a> which actually sends an NUL frame.</p>
<p>Things <b>that cannot be done</b> by Vortex applications, and any other BEEP framework, is to send MSG frames to each other without using reply message (RPY/ERR/ANS/NUL).</p>
<p>Actually you can use only MSG type message to send data to other Vortex (or BEEP) enabled application but this is not the point. Application have to think about MSG type as a request message and RPY as a request reply message. The point is: <b>do not use MSG to reply message received, use RPY/ERR/ANS/NUL types.</b></p>
<h2><a class="anchor" id="vortex_manual_dispatch_schema">
2.2 The Vortex Library Frame receiving dispatch schema (or how incoming frames are read)</a></h2>
<p>Once a frame is received and validated, the Vortex Reader tries to deliver it following next rules:</p>
<ul>
<li>Invoke a second level handler for frame receive event. The second level handler is a user space callback, optionally defined for each channel. Several channel on the same connections may have different second level handlers (or the same) according to its purpose.</li>
</ul>
<ul>
<li>If second level handler for frame receive event were not defined, the Vortex Reader tries to dispatch the frame on the first level handler, which is defined at profile level. This means that channels using the same profiles shares frame receive callback. This allows to defined a general purpose callback at user space for every channel created on every connection.</li>
</ul>
<ul>
<li>Finally, it may happen that a thread wants to keep on waiting for a specific frame to be received bypassing the second and first level handlers. Its is useful for that batch process that can't continue if the frame response is not received. This is called <a class="el" href="starting__to__program.html#vortex_manual_wait_reply">wait reply method</a>.</li>
</ul>
<p>The second and first level handler dispatching method are called asynchronous methods because allows user code to keep on doing other things and to be notified only when frames are received.</p>
<p>The wait reply method is called synchronous dispatch because it blocks the caller thread until the specific frame reply is received. The wait reply method disables the second and first level handler execution.</p>
<p>Having not defined a second or first level handler or wait reply method will cause the Vortex Reader to drop the frame.</p>
<p>Because <a class="el" href="starting__to__program.html#vortex_manual_wait_reply">wait reply method</a> doesn't support receiving all frames in a channel, to perform blocking code, you may also be interested in a mechanism that is implemented on top of the second (or first) level handlers, that allows to get the same functionality that the <a class="el" href="starting__to__program.html#vortex_manual_wait_reply">wait reply method</a>, but including all frames received. Check the following <a class="el" href="group__vortex__channel_ga0a6effe7d63944ad2b332c27bab975a7.html#ga0a6effe7d63944ad2b332c27bab975a7">function to know more about this method</a>.</p>
<p>As you note, the Vortex Library support both method while receiving data: asynchronous method and synchronous method. This is also applied to sending user data.</p>
<h2><a class="anchor" id="vortex_manual_printf_like">
2.3 Printf like interface while sending messages and replies</a></h2>
<p>Additionally, there are also function versions for the previous ones which accepts a variable argument list so you can send message in a printf like fashion.</p>
<div class="fragment"><pre class="fragment">   <span class="keywordflow">if</span> (!<a class="code" href="group__vortex__channel_ga127b45544d6018dedc3d0b2721aef94c.html#ga127b45544d6018dedc3d0b2721aef94c" title="Allows to send message using a printf-like format.">vortex_channel_send_msgv</a> (a_channel, NULL, 
                                  <span class="stringliteral">&quot;Send this message with content: %s and size: %d&quot;</span>, 
                                  content, content_size)) {
         printf (<span class="stringliteral">&quot;Unable to send my message\n&quot;</span>);
   }
</pre></div><p>They are the same function names but appending a "v" at the end.</p>
<h2><a class="anchor" id="vortex_manual_wait_reply">
2.4 Sending data and wait for a specific reply (or how get blocked until a reply arrives)</a></h2>
<p>We have seen in previous section we can use several function to send message in a non-blocking fashion no matter how big the message is: calling to those function will never block. But, what if it is needed to get blocked until a reply is received.</p>
<p>Vortex Library defines a <b>wait reply method</b> allowing to bypass the second and first level handlers defined <a class="el" href="starting__to__program.html#vortex_manual_dispatch_schema">inside the frame received dispatch schema</a>.</p>
<p>Here is an example of code on how to use Wait Reply method:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__vortex__types_gac830c777ca317921af4cf7c038dcf8b7.html#gac830c777ca317921af4cf7c038dcf8b7" title="A Vortex Frame object.">VortexFrame</a>   * frame;
    <span class="keywordtype">int</span>             msg_no;
    <a class="code" href="group__vortex__types_ga9a57b273fb926f418b166483bfb705fc.html#ga9a57b273fb926f418b166483bfb705fc" title="Wait Reply data used for Wait Reply Method.">WaitReplyData</a> * wait_reply;
 
    <span class="comment">// create a wait reply </span>
    wait_reply = <a class="code" href="group__vortex__channel_ga8badc3e8da1799b491b964ff937a5b5b.html#ga8badc3e8da1799b491b964ff937a5b5b" title="Creates a new wait reply to be used to wait for a specific reply.">vortex_channel_create_wait_reply</a> ();
     
    <span class="comment">// now send the message using msg_and_wait/v</span>
    <span class="keywordflow">if</span> (!<a class="code" href="group__vortex__channel_gae586179d47efee5d0fc9bd34e6f2521a.html#gae586179d47efee5d0fc9bd34e6f2521a" title="Allows to send a message and start a wait reply.">vortex_channel_send_msg_and_wait</a> (channel, <span class="stringliteral">&quot;my message&quot;</span>, 
                                           strlen (<span class="stringliteral">&quot;my message&quot;</span>), 
                                           &amp;msg_no, wait_reply)) {
        printf (<span class="stringliteral">&quot;Unable to send my message\n&quot;</span>);
        <a class="code" href="group__vortex__channel_ga9ad0ef43364b7211d96e8ed703f19fa3.html#ga9ad0ef43364b7211d96e8ed703f19fa3" title="Terminates allocated memory by wait reply data.">vortex_channel_free_wait_reply</a> (wait_reply);
    }

    <span class="comment">// get blocked until the reply arrives, the wait_reply object</span>
    <span class="comment">// must not be freed after this function because it already free it.</span>
    frame = <a class="code" href="group__vortex__channel_gab82ec2ad83aa8845fcaf4a24c9b17b75.html#gab82ec2ad83aa8845fcaf4a24c9b17b75" title="Allows caller to wait for a particular reply to be received.">vortex_channel_wait_reply</a> (channel, msg_no, wait_reply);
    <span class="keywordflow">if</span> (frame == NULL) {
         printf (<span class="stringliteral">&quot;there was an error while receiving the reply or a timeout have occur\n&quot;</span>);
    }
    printf (<span class="stringliteral">&quot;my reply have arrived: (size: %d):\n%s&quot;</span>, 
             <a class="code" href="group__vortex__frame_gab375e839af5bcef9556f43fcf5875b18.html#gab375e839af5bcef9556f43fcf5875b18" title="Returns the current payload size the given frame have without taking into account...">vortex_frame_get_payload_size</a> (frame), 
             <a class="code" href="group__vortex__frame_ga2ac165d800ebaca853c7a2634e5c6de4.html#ga2ac165d800ebaca853c7a2634e5c6de4" title="Returns the payload associated to the given frame.">vortex_frame_get_payload</a> (frame));

    <span class="comment">// that&#39;s all!</span>
</pre></div><h2><a class="anchor" id="vortex_manual_invocation_chain">
2.5 Invocation level for frames receive handler</a></h2>
<p>Application designer has to keep in mind the following invocation order for frame received handler: </p>
<ul>
<li>
<p class="startli">First of all, if the frame received is a reply one, that is, a RPY or ERR frame, then Vortex Library look up for waiting thread blocked on <a class="el" href="group__vortex__channel_gab82ec2ad83aa8845fcaf4a24c9b17b75.html#gab82ec2ad83aa8845fcaf4a24c9b17b75">vortex_channel_wait_reply</a>. If found, the frame is delivered and invocation chain is stopped.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If previous lookup was not successful, vortex search for a second level handler defined for the channel which is receiving the frame. This second level handler has been defined by <a class="el" href="group__vortex__channel_ga4e6c15b9779b73be703ea29f5d309085.html#ga4e6c15b9779b73be703ea29f5d309085">vortex_channel_new</a> at channel creation time. If frame received handler is found for this level the invocation chain is stopped.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If previous lookup was not successful, vortex search for a first level handler. This handler have been defined by <a class="el" href="group__vortex__profiles_ga090a544dbe5097f9608401c405f913ff.html#ga090a544dbe5097f9608401c405f913ff">vortex_profiles_register</a> at profile registration. If frame received handler is found for this level the invocation chain is stopped.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Finally, if vortex do not find a way to deliver frame received, then it is dropped (freeing the frame resources and registering a log message)</p>
<p class="endli"></p>
</li>
</ul>
<p>As a consequence: </p>
<ul>
<li>
<p class="startli">If an application don't define any handler then it will only be able to receive frames only through the <a class="el" href="group__vortex__channel_gab82ec2ad83aa8845fcaf4a24c9b17b75.html#gab82ec2ad83aa8845fcaf4a24c9b17b75">vortex_channel_wait_reply</a> function. And of course, this function only allows to receive replies frames so, any message received that is not a reply will be dropped.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If an application defines the first level handler (using <a class="el" href="group__vortex__profiles_ga090a544dbe5097f9608401c405f913ff.html#ga090a544dbe5097f9608401c405f913ff">vortex_profiles_register</a>) this handler will be executed for all frames received for all channel defined under the profile selected.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If an application defines the second level handler (using <a class="el" href="group__vortex__channel_ga4e6c15b9779b73be703ea29f5d309085.html#ga4e6c15b9779b73be703ea29f5d309085">vortex_channel_new</a>) this handler will be executed for all frames received for a particular channel, the one created by <a class="el" href="group__vortex__channel_ga4e6c15b9779b73be703ea29f5d309085.html#ga4e6c15b9779b73be703ea29f5d309085">vortex_channel_new</a> which received the frame received handler.</p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="vortex_manual_profiles">
3.1 Defining a profile inside Vortex (or How profiles concept confuse people)</a></h2>
<p>Now we have to consider to spend some time learning more about profiles. The profile concept inside the BEEP Core definition is the most simple but at the same time seems to be the most confusing.</p>
<p>From a simple point of view, <b>a BEEP profile is what you add to the BEEP protocol to make it useful for you</b>. BEEP provides you building blocks that you have to organize to create a useful protocol. This "protocol configuration" usually involves creating a BEEP profile (or reuse an existing one) extending the BEEP protocol beyond its initial definition to reach your needs.</p>
<p>From the source code point of view, creating a profile only means: </p>
<ul>
<li>
<p class="startli">To register a profile uri using <a class="el" href="group__vortex__profiles_ga090a544dbe5097f9608401c405f913ff.html#ga090a544dbe5097f9608401c405f913ff">vortex_profiles_register</a> and ...</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">To implement the protocol described by the profile. That profile description could be one already defined or one you are defining yourself. You will have to write source that enable your application to send messages and process replies following the profile semantic. This is actually done defining the:</p>
<ul>
<li>
<p class="startli"><a class="el" href="group__vortex__handlers_ga9b856fd8f489ea778799e610eaa0e619.html#ga9b856fd8f489ea778799e610eaa0e619">On frame receive</a> handler. This address the part of the protocol where data is received.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">And, implement the part of the protocol that sends (or replies) data.</p>
<p class="endli"></p>
</li>
</ul>
</li>
</ul>
<p>In other words, because the profile is only a definition on how you should send messages, how to reply to them, and what types of messages you will have to recognize, its content and format, or what will happen on some particular circumstances, it is only needed to register the profile name and to implement that behavior on top of the Vortex Library to fulfill the profile specification.</p>
<p>Maybe the main problem a new BEEP programmer have to face is the fact that a BEEP implementation doesn't allows him to start sending and receiving messages out of the box.</p>
<p>This is because <b>the BEEP definition and Vortex Library implementation is more a toolkit to build application protocols than a ready to use application protocol itself</b>. It is a framework to allow BEEP programmers to define its network protocols in a easy, consistent and maintainable way.</p>
<p>Now see the tutorial about <a class="el" href="profile__example.html">creating a simple profile</a> involving a simple server creation with a simple client.</p>
<h2><a class="anchor" id="vortex_manual_piggyback_support">
4.1 Using piggyback to save one round trip at channel startup</a></h2>
<p>Once defined the application protocol on top of Vortex Library or any other BEEP implementation we could find that creating a channel, involving a request-reply exchange, to later starting to perform real work, represents an initial imposed latency.</p>
<p>This could be easily solved by using piggybacking for the initial messages exchanged. Let's see how channel creation works, without using piggybacking, to later starting to exchange data:</p>
<div class="fragment"><pre class="fragment">    (1) I: A BEEP peer send an &lt;start&gt; channel item ---&gt;

                    &lt;--- (2) L: Remote BEEP peer accept the &lt;start&gt; channel and reply

    (3) I: The BEEP peer send the initial &lt;message&gt; ---&gt;

                    &lt;--- (4) L: Remote BEEP peer receives &lt;message&gt; and reply to it.
</pre></div><p>Previous example shows that underlying BEEP negotiation forces us to waste time, (1) and (2), by creating the channel, and later perform real work for our protocol: (3) and (4).</p>
<p>To solve this, what we have to do is to piggyback the message (3) into the initial (1) start message and to piggyback the reply (4) into the initial reply (2).</p>
<p>This allows to the peer receiving the initial start channel message to process the channel request and later to process the initial message receiving inside it as it where the initial frame received.</p>
<p>Additionally, the BEEP peer that have received the initial message not only reply to the channel start but also uses this first reply done to also reply the initial piggyback received.</p>
<p>As a result, previous example is now like the following:</p>
<div class="fragment"><pre class="fragment">    (1) I: A BEEP peer send an &lt;start&gt; channel item
    (3) I: [The BEEP peer send the initial &lt;message&gt;] ---&gt;

                         (2) L: Remote BEEP peer accept the &lt;start&gt; channel and reply
                    &lt;--- (4) L: [Remote BEEP peer receives &lt;message&gt; and reply to it.]
</pre></div><p>Conclusion: we have saved one round trip, the channel creation initial exchange.</p>
<p>Ok, but how this is actually implemented inside Vortex Library? Well, piggybacking is mostly automatic while using Vortex Library. Let's see how it works for each BEEP peer side.</p>
<p>For the client side, to request creating a new channel and using this initial exchange to send the initial request you could use :</p>
<ul>
<li><a class="el" href="group__vortex__channel_ga51f21e9798bffe9c1136b672b9762c3d.html#ga51f21e9798bffe9c1136b672b9762c3d">vortex_channel_new_full</a></li>
<li><a class="el" href="group__vortex__channel_ga372411d6bdf48c89e1f5845fc2ded1ef.html#ga372411d6bdf48c89e1f5845fc2ded1ef">vortex_channel_new_fullv</a></li>
</ul>
<p>Previous functions will produce a start channel request defining the initial piggyback by using the <b>profile_content</b> parameter.</p>
<p>At the server side, supposing that is a Vortex Library one, it will receive the channel start request and the initial piggyback content, if the <a class="el" href="group__vortex__handlers_ga16e31d142426ca8708abb81ecefbb76e.html#ga16e31d142426ca8708abb81ecefbb76e">OnStartChannelExtended</a> handler is defined to process incoming start request.</p>
<p>On that handler, the initial piggyback received will be the content of the <b>profile_content</b> parameter and the <b>profile_content_reply</b> parameter provides the way to reply to the initial piggyback received.</p>
<p>Here is an example for the <a class="el" href="group__vortex__handlers_ga16e31d142426ca8708abb81ecefbb76e.html#ga16e31d142426ca8708abb81ecefbb76e">OnStartChannelExtended</a> handler: </p>
<div class="fragment"><pre class="fragment">  axl_bool      extended_start_channel (<span class="keywordtype">char</span>              * profile,
                                        <span class="keywordtype">int</span>                 channel_num,
                                        <a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a>  * connection,
                                        <span class="keywordtype">char</span>              * serverName,
                                        <span class="keywordtype">char</span>              * profile_content,
                                   <span class="keywordtype">char</span>             ** profile_content_reply,
                                   <a class="code" href="group__vortex__types_ga934bed5691d6a98fd4ccf66e5d07d73c.html#ga934bed5691d6a98fd4ccf66e5d07d73c" title="Enum value used to report which encoding is being used for the content profile send...">VortexEncoding</a>      encoding,
                                   axlPointer          user_data)
 {
      printf (<span class="stringliteral">&quot;Received a channel start request!\n&quot;</span>);
      <span class="keywordflow">if</span> (profile_content != NULL) {
          <span class="comment">// we have received an initial piggyback, reply to it</span>
          <span class="comment">// by filling up profile_content_reply</span>
          (* profile_content_reply) = ...; <span class="comment">// dynamically allocated message</span>

      }
      <span class="comment">// accept the channel to be created.</span>
      <span class="keywordflow">return</span> axl_true;
 }
</pre></div><p>Piggyback reply processing for client side is more simple. We have two cases: </p>
<ul>
<li>
<p class="startli">1) If the channel creation request was performed by providing a <a class="el" href="group__vortex__handlers_ga50ba395ee0f496d9c27ce0f5560c58c1.html#ga50ba395ee0f496d9c27ce0f5560c58c1">VortexOnChannelCreated</a> application programmer doesn't need to do any special operation, it will receive piggyback reply as the first frame received after <a class="el" href="group__vortex__handlers_ga50ba395ee0f496d9c27ce0f5560c58c1.html#ga50ba395ee0f496d9c27ce0f5560c58c1">VortexOnChannelCreated</a> is executed. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">2) If the channel creation was performed in a synchronous way, without providing <a class="el" href="group__vortex__handlers_ga50ba395ee0f496d9c27ce0f5560c58c1.html#ga50ba395ee0f496d9c27ce0f5560c58c1">VortexOnChannelCreated</a> handler, application programmer have to make a call to <a class="el" href="group__vortex__channel_ga734915705b74ca87d1f02767c7e62bdf.html#ga734915705b74ca87d1f02767c7e62bdf">vortex_channel_have_piggyback</a> to check if a piggyback reply was received and later call to <a class="el" href="group__vortex__channel_gac84a5c974d2782039c6310ef278186b2.html#gac84a5c974d2782039c6310ef278186b2">vortex_channel_get_piggyback</a>.</p>
<p class="endli">Here is an example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// create the channel in a synchronous way</span>
 <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a> * channel = <a class="code" href="group__vortex__channel_ga51f21e9798bffe9c1136b672b9762c3d.html#ga51f21e9798bffe9c1136b672b9762c3d" title="Extended version for vortex_channel_new, supporting all options available while creating...">vortex_channel_new_full</a> (...);
 <a class="code" href="group__vortex__types_gac830c777ca317921af4cf7c038dcf8b7.html#gac830c777ca317921af4cf7c038dcf8b7" title="A Vortex Frame object.">VortexFrame</a>   * reply;
 
 <span class="comment">// check if the channel was created</span>
 <span class="keywordflow">if</span> (channel == NULL) {
     <span class="comment">// unable to create the channel, no piggyback received</span>
     <span class="keywordflow">return</span>;
 }
 
 <span class="comment">// before continue, check for initial piggyback</span>
 <span class="keywordflow">if</span> (<a class="code" href="group__vortex__channel_ga734915705b74ca87d1f02767c7e62bdf.html#ga734915705b74ca87d1f02767c7e62bdf" title="Allows to check if the given channel have piggyback waiting to be processed.">vortex_channel_have_piggyback</a> (channel)) {
      <span class="comment">// get piggyback (the reply for the initial request)</span>
      reply = <a class="code" href="group__vortex__channel_gac84a5c974d2782039c6310ef278186b2.html#gac84a5c974d2782039c6310ef278186b2" title="Allows to get initial piggyback received on the channel start reply.">vortex_channel_get_piggyback</a> (channel);

      <span class="comment">// process it.</span>
      process_reply (reply);
 }
</pre></div>  </li>
</ul>
<p>If you think this is too complicated, that's ok. It means you can survive without using piggyback feature for your protocol. However, many standard BEEP profiles makes use of this feature to be more efficient, like TLS and SASL profiles.</p>
<h2><a class="anchor" id="vortex_manual_using_mime">
4.2 Using MIME configuration for data exchanged under Vortex Library</a></h2>
<p>We have to consider several issues while talking about MIME and MIME inside BEEP.</p>
<p>Initially, MIME was designed to allow transport application protocols, especially SMTP (but later extended to many protocols like HTTP), as a mechanism to notify the application level the content type of the object being received. The same happens with BEEP.</p>
<p>But, what happens when application protocol designers just ignore MIME information, no matter which transport protocol they are using? Again, this only depends on the requirements of the application protocol, mainly because MIME is just an indicator.</p>
<p>In any case, any message exchanged by a BEEP peer must be a conforming MIME message. This implies that at least the empty MIME meader must be appended to each message sent.</p>
<p>For example, you if you send the following message: "test", you or your BEEP toolkit must take care of adding the CR+LF prefix:</p>
<div class="fragment"><pre class="fragment"> MSG 3 1 . 11 6
 
 testEND
</pre></div><p>So, the remote BEEP peer will receive a message with empty MIME headers: CR+LF + "test".</p>
<h3>4.2.1 When should I consider using MIME for a BEEP profile?</h3>
<p>First of all, no matter how you design your profile, MIME will stay at the core of BEEP, and therefore inside your profile. You can ignore its function and nothing will happen (beyond its basic implications that you must consider).</p>
<p>Now, if you pretend to develop a profile that is able to transport <b>everything</b> without previous knowledge (both peers can't make assumptions about the content to be received), it is likely MIME is required. Think about using the more appropiate helper program to open the content received: PNG files, PDF or a C# assembly.</p>
<p>Because MIME is implemented inside Vortex in a way you access to the content (MIME body) and MIME headers (<a class="el" href="group__vortex__frame_ga7ce46526513a84dadd5889b64cf09895.html#ga7ce46526513a84dadd5889b64cf09895">vortex_frame_get_mime_header</a> if defined) in a separated way, it becomes an interesting mechanism to allow extending your profile without modifying its content.</p>
<p>As a conclusion: if your system will be the message producer and the message consumer at the same time, you can safely ignore MIME (but Vortex will produce MIME compliat messages for you, see <a class="el" href="group__vortex__channel_ga1665718f5671ad6cd3bbdce58fb07342.html#ga1665718f5671ad6cd3bbdce58fb07342">vortex_channel_set_automatic_mime</a>), because you can make assumptions about the kind of messages to be exchanged. However, if a third party software is required to be supported, that is initially unknown, or it is required to have some flexible mechanism to notify "additional" information along with your profile messages, you'll need MIME.</p>
<h3>4.2.2 How is MIME implemented inside Vortex Library</h3>
<p>The BEEP protocol definition states that all messages exchanged are MIME objects, that is, arbitrary user application data, that have a MIME header which configures/specify the content. MIME support implemented inside Vortex Library is only structural, that is, it implements MIME structure requirements defined at RFC 2045.</p>
<p>Initially, if you send a message, without using MIME, because you didn't configure anything, then frames generated won't include any MIME header. <b><em>However even in this case, the MIME body start indicator (CR+LF) will be added</em></b>, to allow remote BEEP peer to detect the MIME header (nothing configured) and the MIME body (your message).</p>
<p>For example, if you send message "test" (4 bytes) and no MIME header is configured at any level, it is required to send the following:</p>
<div align="center">
<img src="mime-structure.png" alt="mime-structure.png"/>
<p><strong>MIME struct overview and how it applies to a message without MIME headers</strong></p></div>
<p> That is, even if you do not pay attention to MIME, your messages will still include an inicial CR+LF appended to your message to indicate the remote side no MIME header is defined and to make your message MIME parseable.</p>
<h3>4.2.3 Implicit MIME headers to all messages without MIME information</h3>
<p><b>BEEP assume a MIME implicit configuration</b>, which have the following values for those messages that do not configured "content-type" and "content-transfer-encoding":</p>
<div class="fragment"><pre class="fragment">        Content-Type: application/octet-stream
        Content-Transfer-Encoding: binary
</pre></div><h3>4.2.4 How can I access MIME information on a frame received?</h3>
<p>First of all, in order to complete MIME support, you must have automatic frame joining activated (<a class="el" href="group__vortex__channel_gaf352be87d3fc33fb5cf3eb4607fde99c.html#gaf352be87d3fc33fb5cf3eb4607fde99c">vortex_channel_set_complete_flag</a>). This is by default activated. In the case you are taking full control on frames received you must take care of MIME structure parsing by other means. You still can use <a class="el" href="group__vortex__frame_gad98cd6c503ad102c1ec2d7835833a018.html#gad98cd6c503ad102c1ec2d7835833a018">vortex_frame_mime_process</a> function, but the function will require a frame that contains all the MIME message to work.</p>
<p>Assuming you did receive a complete frame with a MIME message, you can access to the <b>MIME body by calling to</b>: <a class="el" href="group__vortex__frame_ga2ac165d800ebaca853c7a2634e5c6de4.html#ga2ac165d800ebaca853c7a2634e5c6de4">vortex_frame_get_payload</a>.</p>
<p>To access all the message received, including MIME headers and MIME body separator, use <a class="el" href="group__vortex__frame_ga238ef5d8cf5793032ee6ee6f0ae7b664.html#ga238ef5d8cf5793032ee6ee6f0ae7b664">vortex_frame_get_content</a>.</p>
<p>You can use <a class="el" href="group__vortex__frame_ga7ce46526513a84dadd5889b64cf09895.html#ga7ce46526513a84dadd5889b64cf09895">vortex_frame_get_mime_header</a> to access all MIME headers found on the message received (stored on the frame).</p>
<p>Because MIME could allow to have several instances for the same MIME header, <a class="el" href="group__vortex__frame_ga7ce46526513a84dadd5889b64cf09895.html#ga7ce46526513a84dadd5889b64cf09895">vortex_frame_get_mime_header</a> returns a structure (<a class="el" href="group__vortex__types_gac2627166f85b2d3276511047856ca317.html#gac2627166f85b2d3276511047856ca317">VortexMimeHeader</a>) that allows to get the content of the MIME header (<a class="el" href="group__vortex__frame_ga63e9492a7da1f8bcf1e5859646b8f9eb.html#ga63e9492a7da1f8bcf1e5859646b8f9eb">vortex_frame_mime_header_content</a>) but it also allows to get the next instance found for the same MIME header by using <a class="el" href="group__vortex__frame_ga6ac61a5d20651acca46c2946b8d5109a.html#ga6ac61a5d20651acca46c2946b8d5109a">vortex_frame_mime_header_next</a>.</p>
<h3>4.2.5 Automatic MIME configuration for outgoing messages</h3>
<p>The following set of function allows to configure (and check) the values to be configured, on each message sent, for the MIME headers: "Content-Type" and "Content-Transfer-Encoding", in an automatic manner:</p>
<ul>
<li><a class="el" href="group__vortex__profiles_ga884accc35cc44b77e0ab56a65d269059.html#ga884accc35cc44b77e0ab56a65d269059">vortex_profiles_set_mime_type</a></li>
<li><a class="el" href="group__vortex__profiles_gab7c3d84b55c5a32e0c1d2585aab88c5b.html#gab7c3d84b55c5a32e0c1d2585aab88c5b">vortex_profiles_get_mime_type</a></li>
<li><a class="el" href="group__vortex__profiles_ga40505cf1ee80a0f54b829aa719624804.html#ga40505cf1ee80a0f54b829aa719624804">vortex_profiles_get_transfer_encoding</a></li>
</ul>
<p>However, this mechanism doesn't fit properly if it is required to send arbitrary MIME objects (with diffent MIME headers) under the same profile, because previous configuration will append the same MIME information to every message being sent via:</p>
<ul>
<li><a class="el" href="group__vortex__channel_ga69167b79eaca52375ced805c13125cd8.html#ga69167b79eaca52375ced805c13125cd8">vortex_channel_send_msg</a></li>
<li><a class="el" href="group__vortex__channel_ga127b45544d6018dedc3d0b2721aef94c.html#ga127b45544d6018dedc3d0b2721aef94c">vortex_channel_send_msgv</a></li>
<li><a class="el" href="group__vortex__channel_gae586179d47efee5d0fc9bd34e6f2521a.html#gae586179d47efee5d0fc9bd34e6f2521a">vortex_channel_send_msg_and_wait</a></li>
<li><a class="el" href="group__vortex__channel_gaf45dc7a82e996b3f19d1252258fcd42f.html#gaf45dc7a82e996b3f19d1252258fcd42f">vortex_channel_send_rpy</a></li>
<li><a class="el" href="group__vortex__channel_ga0a7d3b38262723d8614a5654db6f48aa.html#ga0a7d3b38262723d8614a5654db6f48aa">vortex_channel_send_rpyv</a></li>
<li><a class="el" href="group__vortex__channel_ga3ef260bc9f143b8bb13df7ddf79cf0ea.html#ga3ef260bc9f143b8bb13df7ddf79cf0ea">vortex_channel_send_err</a></li>
<li><a class="el" href="group__vortex__channel_ga1b1688241dfc56af9d2e319e266c208b.html#ga1b1688241dfc56af9d2e319e266c208b">vortex_channel_send_errv</a></li>
<li><a class="el" href="group__vortex__channel_ga6c2e3867ab784a80a46462db4083e03e.html#ga6c2e3867ab784a80a46462db4083e03e">vortex_channel_send_ans_rpy</a></li>
<li><a class="el" href="group__vortex__channel_gae5b17e73ea25b11c9d63411c819ec1a1.html#gae5b17e73ea25b11c9d63411c819ec1a1">vortex_channel_send_ans_rpyv</a></li>
</ul>
<p>In the case no MIME configuration is found for the profile, previous functions will prepend the MIME header separator "CR+LF" on each message sent. This allows to produce MIME compliant messages that have an empty MIME header configuration.</p>
<h3>4.2.5 Disabling automatic MIME configuration for outgoing messages</h3>
<p>Under some situations it is required to send already configured MIME objects through the set of functions previously described. Because those functions will automatically add an empty MIME header (CR+LF) to each message sent, is required to disable this behavior to avoid breaking message MIME configuration.</p>
<p>This is done using the following set of functions. They work at library, profile and channel level, having preference the channel level. In order of preference:</p>
<ul>
<li><a class="el" href="group__vortex__channel_ga1665718f5671ad6cd3bbdce58fb07342.html#ga1665718f5671ad6cd3bbdce58fb07342">vortex_channel_set_automatic_mime</a></li>
<li><a class="el" href="group__vortex__channel_ga0738f81ad0cf7ca70d35c0cfb2d1770e.html#ga0738f81ad0cf7ca70d35c0cfb2d1770e">vortex_channel_get_automatic_mime</a></li>
<li><a class="el" href="group__vortex__profiles_ga825dd8c55d1d123424c0e4e86f3136e6.html#ga825dd8c55d1d123424c0e4e86f3136e6">vortex_profiles_set_automatic_mime</a></li>
<li><a class="el" href="group__vortex__profiles_ga5f4b7c23cd7e43b6dc5f41375f7730a8.html#ga5f4b7c23cd7e43b6dc5f41375f7730a8">vortex_profiles_get_automatic_mime</a></li>
<li><a class="el" href="group__vortex_ga64488d4a3700d5703581e476e769c594.html#ga64488d4a3700d5703581e476e769c594">vortex_conf_set</a> (<a class="el" href="group__vortex_gac43338dcc0fc7640cb7fc0c8c319abf2.html#ggac43338dcc0fc7640cb7fc0c8c319abf2af608c4d5f3806bfc7ffd27c4e69a907f">VORTEX_AUTOMATIC_MIME_HANDLING</a>)</li>
</ul>
<p>For example, disabling automatic MIME handling at profile level while cause Vortex Engine to not append any MIME header (including the body separator) to messages sent over a channel running a particular profile:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// disable MIME automatic headers for the following profile</span>
 <a class="code" href="group__vortex__profiles_ga825dd8c55d1d123424c0e4e86f3136e6.html#ga825dd8c55d1d123424c0e4e86f3136e6" title="Allows to configure automatic MIME header addition handling at profile level.">vortex_profiles_set_automatic_mime</a> (<span class="stringliteral">&quot;urn:beep:some-profile&quot;</span>, 2);
</pre></div><p>Special attention is required to the following code because it doesn't disable MIME handling but deffer the decision to the global library configuration, which is by default activated:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// signal to use library current configuration</span>
 <a class="code" href="group__vortex__profiles_ga825dd8c55d1d123424c0e4e86f3136e6.html#ga825dd8c55d1d123424c0e4e86f3136e6" title="Allows to configure automatic MIME header addition handling at profile level.">vortex_profiles_set_automatic_mime</a> (<span class="stringliteral">&quot;urn:beep:some-profile&quot;</span>, 0);
</pre></div><p>In any case, if the Vortex Engine finds the MIME automatic headers disabled, it will take/send messages received "as is", being the application level the responsible of producting MIME compliant messages.</p>
<p><em><b>NOTE:</b> If the channel MIME handling (<a class="el" href="group__vortex__channel_ga1665718f5671ad6cd3bbdce58fb07342.html#ga1665718f5671ad6cd3bbdce58fb07342">vortex_channel_set_automatic_mime</a>) isn't configured (<a class="el" href="group__vortex__channel_ga0738f81ad0cf7ca70d35c0cfb2d1770e.html#ga0738f81ad0cf7ca70d35c0cfb2d1770e">vortex_channel_get_automatic_mime</a> returns 0) but the profile level (<a class="el" href="group__vortex__profiles_ga5f4b7c23cd7e43b6dc5f41375f7730a8.html#ga5f4b7c23cd7e43b6dc5f41375f7730a8">vortex_profiles_get_automatic_mime</a>) or library level (<a class="el" href="group__vortex_gab67080bcdbb009d1de0bd203aad1f3c0.html#gab67080bcdbb009d1de0bd203aad1f3c0">vortex_conf_get</a> <a class="el" href="group__vortex_gac43338dcc0fc7640cb7fc0c8c319abf2.html#ggac43338dcc0fc7640cb7fc0c8c319abf2af608c4d5f3806bfc7ffd27c4e69a907f">VORTEX_AUTOMATIC_MIME_HANDLING</a>) are configured, then the configuration is copied into the channel. This is done to improve library performance.</em></p>
<h3>4.2.6 Default configuration for automatic MIME header handling. </h3>
<p>By default only library level comes activates (<a class="el" href="group__vortex_ga64488d4a3700d5703581e476e769c594.html#ga64488d4a3700d5703581e476e769c594">vortex_conf_set</a> <a class="el" href="group__vortex_gac43338dcc0fc7640cb7fc0c8c319abf2.html#ggac43338dcc0fc7640cb7fc0c8c319abf2af608c4d5f3806bfc7ffd27c4e69a907f">VORTEX_AUTOMATIC_MIME_HANDLING</a>). This means that, without any configuration, all channels created will automatically add a MIME header for each message sent.</p>
<p><em><b>NOTE:</b> In the case no configuration is found on every level (0 is returned at <a class="el" href="group__vortex__channel_ga0738f81ad0cf7ca70d35c0cfb2d1770e.html#ga0738f81ad0cf7ca70d35c0cfb2d1770e">vortex_channel_get_automatic_mime</a>, <a class="el" href="group__vortex__profiles_ga5f4b7c23cd7e43b6dc5f41375f7730a8.html#ga5f4b7c23cd7e43b6dc5f41375f7730a8">vortex_profiles_get_automatic_mime</a>, <a class="el" href="group__vortex_gab67080bcdbb009d1de0bd203aad1f3c0.html#gab67080bcdbb009d1de0bd203aad1f3c0">vortex_conf_get</a> <a class="el" href="group__vortex_gac43338dcc0fc7640cb7fc0c8c319abf2.html#ggac43338dcc0fc7640cb7fc0c8c319abf2af608c4d5f3806bfc7ffd27c4e69a907f">VORTEX_AUTOMATIC_MIME_HANDLING</a>), then it is assumed automatic MIME handling is activated.</em></p>
<h3>4.2.7 What happens if a wrong MIME formated message is received. </h3>
<p>From a frame perspective (BEEP framing mechanism), the vortex engine considers as valid frames all of them as long as BEEP framing rules are observed.</p>
<p>From a MIME perspective, which is considered on top of the BEEP framing mechanism, if the message inside a <a class="el" href="group__vortex__types_gac830c777ca317921af4cf7c038dcf8b7.html#gac830c777ca317921af4cf7c038dcf8b7">VortexFrame</a> is not MIME ready, the content returned by the function <a class="el" href="group__vortex__frame_ga238ef5d8cf5793032ee6ee6f0ae7b664.html#ga238ef5d8cf5793032ee6ee6f0ae7b664">vortex_frame_get_content</a> and <a class="el" href="group__vortex__frame_ga2ac165d800ebaca853c7a2634e5c6de4.html#ga2ac165d800ebaca853c7a2634e5c6de4">vortex_frame_get_payload</a> will be same, that is, <b><em>the message received is returned untouched</em></b>.</p>
<p>Obviously, under this situation, all API that belongs to the MIME support will provide no function:</p>
<ul>
<li>For example, <a class="el" href="group__vortex__frame_ga7ce46526513a84dadd5889b64cf09895.html#ga7ce46526513a84dadd5889b64cf09895">vortex_frame_get_mime_header</a> and <a class="el" href="group__vortex__frame_ga17a8d35a91726b629fc82ec0f1f2d597.html#ga17a8d35a91726b629fc82ec0f1f2d597">vortex_frame_get_mime_header_size</a> will provide NULL and 0 content.</li>
</ul>
<p>So, <b><em>if a message not conforming MIME rules is received, Vortex won't discard it, and it will be delivered "as is" to frame delivery handlers defined.</em></b> Under this situation, a log will be reported to signal that a MIME parse error was found: </p>
<div class="fragment"><pre class="fragment"> (proc 25045): (warning) vortex-reader: failed to update MIME status <span class="keywordflow">for</span> the frame, <span class="keywordflow">continue</span> delivery
</pre></div><h3>4.2.8 Could new MIME support break compatibility with previous Vortex Library? </h3>
<p>It is possible under some situations. Before Vortex Library 1.0.15 and its corresponding 1.1.0 release, a bug was fixed in the way messages was produced. In the case no MIME header was configured, the message produced wasn't prefixed by a CR+LF pair. This is wrong since the remote BEEP peer expects to receive a MIME compliant message, with at least the CR+LF to signal that no MIME header was configured.</p>
<p>In any case, if problems are found, these are the solutions:</p>
<p>1) The obvious solution is to upgrade both (client and server) peers to support same MIME implementation.</p>
<p>2) In the case you want to only update your BEEP client but still connect to Vortex peers running 1.0.14 or previous, you have to disable automatic MIME header handling. See previous sections. A direct hack to disable it globally could be:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// library level desactivation for automatic MIME header </span>
 <a class="code" href="group__vortex_ga64488d4a3700d5703581e476e769c594.html#ga64488d4a3700d5703581e476e769c594" title="Allows to configure the provided item, with either the integer or the string value...">vortex_conf_set</a> (ctx, <a class="code" href="group__vortex_gac43338dcc0fc7640cb7fc0c8c319abf2.html#ggac43338dcc0fc7640cb7fc0c8c319abf2af608c4d5f3806bfc7ffd27c4e69a907f" title="If configured, makes all messages send via vortex_channel_send_* to automatically...">VORTEX_AUTOMATIC_MIME_HANDLING</a>, 2, NULL);
</pre></div><p>3) In the case you want to only upgrade your BEEP listener, but you still want to receive connections from old and new clients, nothing special is required. This is automatically supported by new vortex engine.</p>
<p>No other compatibility issue is reported.</p>
<h2><a class="anchor" id="vortex_manual_implementing_request_response_pattern">
3.2 Implementing the request-response pattern</a></h2>
<p>When it comes to implement the request/response interaction pattern, BEEP is a great choice. On this section, it is provided some tips to enable people to properly implement this pattern type with Vortex Library.</p>
<p>While implementing the request/response pattern the very first thing to control is how a reply is processed. If pattern is implemented using a synchronous invocation, there is not too much problems. The fun comes while implementing it in an asynchronous manner.</p>
<p>Asynchronous, request/response, pattern needs to solve how to associate and process replies received with the proper handler provided at the time the request was performed. Inside Vortex Library, asynchronous request replies are processed by providing a <a class="el" href="group__vortex__handlers_ga9b856fd8f489ea778799e610eaa0e619.html#ga9b856fd8f489ea778799e610eaa0e619">frame received handler</a> (provided at <a class="el" href="group__vortex__channel_ga4e6c15b9779b73be703ea29f5d309085.html#ga4e6c15b9779b73be703ea29f5d309085">vortex_channel_new</a> or <a class="el" href="group__vortex__channel_ga51f21e9798bffe9c1136b672b9762c3d.html#ga51f21e9798bffe9c1136b672b9762c3d">vortex_channel_new_full</a>).</p>
<p>However, this handler is provided at the channel creation time, making it available to all requests performed under that channel.</p>
<p>The very first thought to solve previous problem is to provide a different frame receive with some application data for every request performed so each reply is processed by its corresponding handler. This is actually done by using <a class="el" href="group__vortex__channel_ga1984eb181399be3c3944387077e240f1.html#ga1984eb181399be3c3944387077e240f1">vortex_channel_set_received_handler</a>.</p>
<p>Well, this will cause a race condition making responses to be processed by request handlers that are not the associated. This is because the frame receive handler for a channel could be only one at the same time, which is applied to all messages replies received on the given channel. Several call to this function will make that the frame received handler set, will be the value set on the last call to this function.</p>
<p>This means that, if several request are performed, followed by its corresponding call to this function, and knowing that several request on the same channel are replied in the same other they were issued, the frame received handler that will process the first message will be the last one set not the one set for that first message.</p>
<p>Here is an example of code on how to produce a race condition: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// set the frame received for the request A</span>
 <a class="code" href="group__vortex__channel_ga1984eb181399be3c3944387077e240f1.html#ga1984eb181399be3c3944387077e240f1" title="Allows to set the frame received handler.">vortex_channel_set_received_handler</a> (channel, process_requestA, data_A);

 <span class="comment">// perform request A</span>
 <a class="code" href="group__vortex__channel_ga69167b79eaca52375ced805c13125cd8.html#ga69167b79eaca52375ced805c13125cd8" title="Sends the message over the selected channel.">vortex_channel_send_msg</a> (channel, <span class="stringliteral">&quot;request A&quot;</span>, 9, NULL);


 <span class="comment">// set the frame received for the request B</span>
 <a class="code" href="group__vortex__channel_ga1984eb181399be3c3944387077e240f1.html#ga1984eb181399be3c3944387077e240f1" title="Allows to set the frame received handler.">vortex_channel_set_received_handler</a> (channel, process_requestB, data_B);

 <span class="comment">// perform request B</span>
 <a class="code" href="group__vortex__channel_ga69167b79eaca52375ced805c13125cd8.html#ga69167b79eaca52375ced805c13125cd8" title="Sends the message over the selected channel.">vortex_channel_send_msg</a> (channel, <span class="stringliteral">&quot;request B&quot;</span>, 9, NULL);
</pre></div><p>Obviously, this seems to be pretty clear if you place the problem at a very few lines. However, previous interactions are usually produced by a function called, in your code that is likely to be named as <b>make_invocation</b>, which calls to <a class="el" href="group__vortex__channel_ga1984eb181399be3c3944387077e240f1.html#ga1984eb181399be3c3944387077e240f1">vortex_channel_set_received_handler</a> and then to <a class="el" href="group__vortex__channel_ga69167b79eaca52375ced805c13125cd8.html#ga69167b79eaca52375ced805c13125cd8">vortex_channel_send_msg</a>, which starts to be not so obvious.</p>
<p>The key concept here is to ensure that every message reply to be received must be processed by the right frame receive handler. This could be accomplish using several techniques:</p>
<ul>
<li>
<p class="startli">If you are using a request/response pattern, you have to know that several request/response patterns could not be under the same channel without having blocking problems usually called <b>head-of-line</b>.</p>
<p>You are likely to be interested in using a different channel to perform the request/response invocation or to wait to use an already existing channel that is ready to be used without blocking you.</p>
<p>This <b>ready</b> feature is interpreted in our context as a channel that is not waiting for any previous request performed, that will make our new request to get blocked until the previous is served.</p>
<p>To get current status for a channel to be <b>ready</b> you could use <a class="el" href="group__vortex__channel_ga11704c9cdca0b35890345851f3f850d2.html#ga11704c9cdca0b35890345851f3f850d2">vortex_channel_is_ready</a> function. In the case a channel is <b>not ready</b>, that is, is already waiting for a reply, you <b>should NOT</b> modify current frame receive handler because you'll make your new frame receive handler to process previous reply.</p>
<p>In the case a channel is not ready you can wait until the channel is ready, or to create a new channel to perform the invocation. For the second option, you'll be interested on using the <a class="el" href="group__vortex__channel__pool.html">Vortex Channel Pool</a> module and its features to get the next ready channel automatically negotiating a new channel if there is no ready channel available.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>The alternative is to create a channel and close it for each request/response performed. This will allow to have a clear implementation, with a particular frame receive handler for each channel. The question is that this have a really great performance impact. Using this technique your program will do for every request:</p>
<ul>
<li>Create a channel (sending a channel request and make your program wait for its reply).</li>
<li>Perform the request/response pattern (sending the request and waiting for the response).</li>
<li>Close the channel (sending a close channel request and make your program wait for its reply).</li>
</ul>
<p>As a consequence you have to exchange 6 messages for every request done. For 100 request/response your program will have to exchange <b>600 messages. </b></p>
<p>Using the <a class="el" href="group__vortex__channel__pool.html">Vortex Channel Pool</a>, with 10 channels, your program will exchange 20 messages (for channels to be created) plus 20 messages (for channels to be closed) plus 200 exchanges (100 request + 100 responses), total = <b>220 messages.</b></p>
<p></p>
<p class="endli"></p>
</li>
</ul>
<p>At any case it is recommended, while using the request/response pattern, to use the <a class="el" href="group__vortex__channel__pool.html">Channel Pool</a> feature which will allow you to avoid race conditions while getting a channel that is ready but being asked by several threads at the same time. It will also negotiate for you a new channel to be created if the channel pool doesn't have any channel in the ready state.</p>
<p>It is really easy to change current code implemented to use vortex channel pool. Here is an example:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__vortex__types_ga8335cf8b240d5f8a6ae9407a3c050bbf.html#ga8335cf8b240d5f8a6ae9407a3c050bbf" title="Vortex Channel Pool definition.">VortexChannelPool</a> * pool;
 <span class="keywordtype">void</span> init_channel_pool (<a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection) {

    <span class="comment">// create the channel pool (this should be done for each </span>
    <span class="comment">// connection only one time avoiding several threads to call this</span>
    <span class="comment">// function</span>

     pool = <a class="code" href="group__vortex__channel__pool_gaa7130833a4500c9647fd84ad21dc2093.html#gaa7130833a4500c9647fd84ad21dc2093" title="Creates a new pool of VortexChannel items, that are managed in a way that ensure...">vortex_channel_pool_new</a> (connection,
                                     COYOTE_SIMPLE_URI,
                                     1, <span class="comment">// how many channels to be created at first time</span>
                                     <span class="comment">// close handler stuff</span>
                                     NULL, NULL, 
                                     <span class="comment">// received handler stuff (set it to null)</span>
                                     NULL, NULL,
                                     <span class="comment">// async notification for pool creation stuff</span>
                                     NULL, NULL);
 }
 
 <a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a> * get_channel_available (<a class="code" href="group__vortex__handlers_ga9b856fd8f489ea778799e610eaa0e619.html#ga9b856fd8f489ea778799e610eaa0e619" title="Async notifier for frame received event.">VortexOnFrameReceived</a> received,
                                        axlPointer            user_data) {

      <span class="comment">// get the next channel available (this function could be</span>
      <span class="comment">// called by several threads at the same time</span>

      result = <a class="code" href="group__vortex__channel__pool_ga3336a50e2f4437f64aa3334c4837ba02.html#ga3336a50e2f4437f64aa3334c4837ba02" title="Returns the next &amp;quot;ready to use&amp;quot; channel from the given pool.">vortex_channel_pool_get_next_ready</a> (pool, axl_true);
 
      <span class="comment">// now, Vortex API is ensuring us we are the only one owner for the channel</span>
      <span class="comment">// result, let&#39;s change the frame receive handler</span>
      <a class="code" href="group__vortex__channel_ga1984eb181399be3c3944387077e240f1.html#ga1984eb181399be3c3944387077e240f1" title="Allows to set the frame received handler.">vortex_channel_set_received_handler</a> (result, received, user_data);
 
      <span class="comment">// return the channel</span>
      <span class="keywordflow">return</span> result;
 }

 <span class="keywordtype">void</span> release_channel (<a class="code" href="group__vortex__types_ga9dab9d627d67bfc4cccf2687725ee60f.html#ga9dab9d627d67bfc4cccf2687725ee60f" title="A Vortex Channel object.">VortexChannel</a> * channel) {

      <span class="comment">// once finished release the channel, to return it to the</span>
      <span class="comment">// pool. The following must be do only, and only once the</span>
      <span class="comment">// channel have received its reply.</span>

      <a class="code" href="group__vortex__channel__pool_ga640cf86cb4cf7ddff6a03823208c1b14.html#ga640cf86cb4cf7ddff6a03823208c1b14" title="Release a channel from the channel pool.">vortex_channel_pool_release_channel</a> (pool, channel);
 }
</pre></div><p>Previous source code have tree functions. Here is the explanation:</p>
<ul>
<li><b>init_channel_pool:</b> For every connection to be used, this function should be called to create a channel pool. Channel pool created on a connection get closely associated to it. This must be done only one time, commonly at the connection creation process.</li>
</ul>
<ul>
<li><b>get_channel_available:</b> Instead of create a channel calling normal interface provided (<a class="el" href="group__vortex__channel_ga4e6c15b9779b73be703ea29f5d309085.html#ga4e6c15b9779b73be703ea29f5d309085">vortex_channel_new</a> and <a class="el" href="group__vortex__channel_ga51f21e9798bffe9c1136b672b9762c3d.html#ga51f21e9798bffe9c1136b672b9762c3d">vortex_channel_new_full</a>), a call to this function is done, providing the frame received handler and its associated user space data. This function is usually called just before the request is performed to get the channel to be used. The channel returned is ensured to be not waiting for a previous request, and the the next request to be performed, will be processed with the <a class="el" href="group__vortex__handlers_ga9b856fd8f489ea778799e610eaa0e619.html#ga9b856fd8f489ea778799e610eaa0e619">frame received</a> handler provided.</li>
</ul>
<ul>
<li><b>release_channel: </b> Once the reply is received, and only once, the channel must be release to the channel pool so it could be reused for other request.</li>
</ul>
<h2><a class="anchor" id="vortex_manual_changing_vortex_io">
3.3 Configuring Vortex Library IO layer</a></h2>
<p>Default Vortex Library implementation doesn't require you to pay attention to such details like:</p>
<ul>
<li>How Vortex Library sends and receives data from underlying transport.</li>
</ul>
<ul>
<li>How Vortex Library IO blocking mechanism is used to wait until a set of file descriptors changes.</li>
</ul>
<p>However, it turns out that these are topics that are likely to be asked. For your information, Vortex Library internal function have a default configuration that makes uses of the BSD <b>send</b> and <b>recv</b> function to perform IO read and write operations. This default configuration could be changed by using the following function which are specific for each connection:</p>
<ul>
<li><a class="el" href="group__vortex__connection_ga7052b9c3428a5b6ab65794ca31abd521.html#ga7052b9c3428a5b6ab65794ca31abd521">vortex_connection_set_receive_handler</a></li>
<li><a class="el" href="group__vortex__connection_ga9c20f9f6d2870529e49491f9bd51ee2d.html#ga9c20f9f6d2870529e49491f9bd51ee2d">vortex_connection_set_send_handler</a></li>
</ul>
<p>As an example, Vortex TLS implementation uses previous handlers to configure how Vortex Library reads and sends its data once the TLS negotiation have finished. This allows to keep on writing higher level code that expect to have a function that is able to send and receive data from its underlying transport socket, no matter if it is TLS-ficated (<a class="el" href="group__vortex__connection_ga418ee4df18dd89a6363c67fa8e24ba6c.html#ga418ee4df18dd89a6363c67fa8e24ba6c">vortex_connection_is_tlsficated</a>).</p>
<p>User space only needs to implement a small piece of code inside the handler required and Vortex Library will call it at the right time. Previous function requires to define the following handlers:</p>
<ul>
<li>To perform read operations from a <a class="el" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4">VortexConnection</a> a handler <a class="el" href="group__vortex__handlers_ga458bd7e803c3ac921ed2bb5beabaf925.html#ga458bd7e803c3ac921ed2bb5beabaf925">VortexReceiveHandler</a> must be provided.</li>
</ul>
<ul>
<li>To perform send operations from a <a class="el" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4">VortexConnection</a> a handler <a class="el" href="group__vortex__handlers_ga4da1bbcf2f799c8a72883a1ee7095134.html#ga4da1bbcf2f799c8a72883a1ee7095134">VortexSendHandler</a> must be provided.</li>
</ul>
<p>You'll find that previous definition doesn't allows to pass in a pointer to the function so you could implement a kind of special operation based on the data received. To accomplish this task, you should use the following set of function which will allow you to store arbitrary data inside a connection, key-index hash like, even allowing the destroy function to be used once the connection is closed or the value is replaced:</p>
<ul>
<li><a class="el" href="group__vortex__connection_ga196723d6bcc2c4f51f899404e09145ee.html#ga196723d6bcc2c4f51f899404e09145ee">vortex_connection_set_data</a></li>
<li><a class="el" href="group__vortex__connection_ga5b6f3568c62473db854ecc4062619adc.html#ga5b6f3568c62473db854ecc4062619adc">vortex_connection_set_data_full</a></li>
<li><a class="el" href="group__vortex__connection_ga8918f4f3350fec46341dbdc0231fa86c.html#ga8918f4f3350fec46341dbdc0231fa86c">vortex_connection_get_data</a></li>
</ul>
<p>For the case of the IO blocking mechanism, Vortex now checks for the presence of select(2), poll(2) and epoll(2) system call, selecting the best mechanism to be used by default. However, you can change to the desired mechanism at run time (even during transmission!) using:</p>
<ul>
<li><a class="el" href="group__vortex__io_ga2877e3be486c103348f871d4afa3b01e.html#ga2877e3be486c103348f871d4afa3b01e">vortex_io_waiting_use</a>, providing the appropriate value for <a class="el" href="group__vortex__types_ga5f8b367ff5c108b69c8e99276d63247e.html#ga5f8b367ff5c108b69c8e99276d63247e">VortexIoWaitingType</a>.</li>
</ul>
<ul>
<li>Use <a class="el" href="group__vortex__io_ga29f9df2f8d026412f131beea811560e0.html#ga29f9df2f8d026412f131beea811560e0">vortex_io_waiting_get_current</a> to know which is the I/O mechanism currently installed.</li>
</ul>
<p>Previous functions, provides a built-in mechanism to select already implemented mechanism. In the case you want to provide your own user space implementation to handling I/O waiting, you can use the following handlers to define the functions to be executed by the Vortex I/O engine at the appropriate time:</p>
<ul>
<li>
<p class="startli">The following handler should be used to set the function that will create the structured commonly used that holds the set of socket descriptors that will be watched:</p>
<ul>
<li><a class="el" href="group__vortex__io_ga43f1a9e0d082cc70af70a5c063efeeca.html#ga43f1a9e0d082cc70af70a5c063efeeca">vortex_io_waiting_set_create_fd_group</a> </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Then, the following function should define handlers to perform a clearing operation, a adding socket descriptor into a fd set operation and a destroy descriptor operation. This last one is used to destroy the fd set returned by executing the handler <a class="el" href="group__vortex__io_ga43f1a9e0d082cc70af70a5c063efeeca.html#ga43f1a9e0d082cc70af70a5c063efeeca">vortex_io_waiting_set_create_fd_group</a>.</p>
<ul>
<li><a class="el" href="group__vortex__io_ga471263c2bd30e318c0b94cca12811ed4.html#ga471263c2bd30e318c0b94cca12811ed4">vortex_io_waiting_set_clear_fd_group</a></li>
<li><a class="el" href="group__vortex__io_ga1918bba1250c889291933a4c65cbfd57.html#ga1918bba1250c889291933a4c65cbfd57">vortex_io_waiting_set_add_to_fd_group</a></li>
<li><a class="el" href="group__vortex__io_ga1438178d2873eddec21479777253f375.html#ga1438178d2873eddec21479777253f375">vortex_io_waiting_set_destroy_fd_group</a></li>
</ul>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Once done that, a handler to implement the IO blocking operation until some socket descriptor change must be defined at the following function:</p>
<ul>
<li><a class="el" href="group__vortex__io_ga8a321a16b60b0322434ea7e7fd34065f.html#ga8a321a16b60b0322434ea7e7fd34065f">vortex_io_waiting_set_wait_on_fd_group</a></li>
</ul>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Once the previous function returns because there are socket with operations to perform, a handler to get current activation status, for a given socket against the fd set, must be defined.</p>
<ul>
<li><a class="el" href="group__vortex__io_ga5a79e3ea8baafb77bfe9556afb33727d.html#ga5a79e3ea8baafb77bfe9556afb33727d">vortex_io_waiting_set_is_set_fd_group</a></li>
</ul>
<p></p>
<p class="endli"></p>
</li>
</ul>
<p>Previous handlers must be defined as a whole, it is not possible to only define a certain piece reusing the rest of the handlers. If the handlers are properly implemented, they will allow Vortex Library to perform IO operation with the API you have provided.</p>
<p>As an example, inside the IO module (<b>vortex_io.c</b>) can be found current implementation for all I/O mechanism supported by the library.</p>
<h2><a class="anchor" id="vortex_manual_transfering_files">
4.3 General considerations about transfering files</a></h2>
<p>There are several methods that can be used to transfer a file. They differ in the way they consume memory and how difficult they are to properly implement them. These methods are:</p>
<ul>
<li><b>FIRST METHOD:</b> Sending the file in one single MSG frame.</li>
<li><b>SECOND METHOD:</b> Sending the file in a set of MSG frames that are composed by the remote side.</li>
<li><b>THIRD METHOD:</b> Sending the file in a set of ANS frames that are composed by the remote side.</li>
</ul>
<p>The first method (sending one big single MSG) it's the most simple. It is not required to split the file and assamble it in the remote side.</p>
<p>However, this method consumes a lot of memory because in general terms you must load all the file into memory, them pass it to the Vortex API, which also does its own copy, now you have twice memory loaded and them the memory is retained until the message is completely sent in smallers MSG frames.</p>
<p>In the same direction, people using this method usually do not configure <a class="el" href="group__vortex__channel_gaf352be87d3fc33fb5cf3eb4607fde99c.html#gaf352be87d3fc33fb5cf3eb4607fde99c">vortex_channel_set_complete_flag</a> which causes all frames conforming the big message to be hold into memory at the remote side until the last frame is received. In this case, once the last message is received, Vortex will allocate enough memory to consolidate all frames into one single content. Again, more memory consumed.</p>
<p>So, <b>FIRST METHOD</b> is easy, but <b>really poor in performance terms</b>.</p>
<p><em><b>NOTE:</b> the fact that vortex has the hability to split your messages into the allowed remote channel window size is at the same time a valuable feature and a source of problems. This automatic splitting makes more easy to do not care about content size sent. So, as a general rule, try to control the size of the content sent.</em></p>
<p><b>SECOND METHOD</b> involves the developer in the process of preparing the content to be sent, and to take advantage of local store. In this method, the sender open the file and reads chunks of 2k/4k/8k/12k/16k, and send them by using MSG frames.</p>
<p>This makes memory consumption to be lower than previous case because the entire file isn't loaded and, as the transfer progress, the remote side can consolidate all chunks received directly into a file rather holding it into memory.</p>
<p>This method also requires that <a class="el" href="group__vortex__handlers_ga9b856fd8f489ea778799e610eaa0e619.html#ga9b856fd8f489ea778799e610eaa0e619">frame received</a> activation to be serialized because you have to place all pieces received in other. This is archived by using <a class="el" href="group__vortex__channel_gaaa3be5408ec9995129390c9e9760b7bb.html#gaaa3be5408ec9995129390c9e9760b7bb">vortex_channel_set_serialize</a>.</p>
<p>This method is more difficult but results are better. The same happens to the following method.</p>
<p><b>THIRD METHOD</b> involves doing pretty much the same like SECOND METHOD, but using ANS/NUL (one-to-many) exchange style.</p>
<p>Because BEEP requires all issued MSG to be replied, in the second method each MSG sent requires the receiving side to reply with a RPY (usually empty). This is not required with ANS/NUL exchange style.</p>
<p>In this case, we ask the receiving side to issue a MSG request (asking for download the file). Then, the sending side opens the file to be transferred and send its pieces by using ANS messages.</p>
<p>The receiving side consolidates into file all pieces received without requiring to reply to each ANS message received.</p>
<p><b>THIRD METHOD</b> is the best in terms of memory consuption and network efficiency.</p>
<p>We have also to consider other key factors for an effective and fast transfer. In general they are two: window size and frame fragmentation.</p>
<p>The first concept (<b>window size</b>) is part of the BEEP way to do channel flow control (see <a href="http://www.beepcore.org/seq_frames.html">http://www.beepcore.org/seq_frames.html</a>). The initial window size for all channels is 4k. This value must be elevated to something bigger that fits your environment. This is controlled via <a class="el" href="group__vortex__channel_ga70b67340077d938384769e1ca5773cf4.html#ga70b67340077d938384769e1ca5773cf4">vortex_channel_set_window_size</a>.</p>
<p>The second concept (<b>frame fragmentation</b>) talks about how your messages are splitted in the case they don't fit into the remote window size. Take a look on the following handler: <a class="el" href="group__vortex__handlers_ga5e7d5d0a552e813b9eb6fea64f23c904.html#ga5e7d5d0a552e813b9eb6fea64f23c904">VortexChannelFrameSize</a></p>
<p>Now take a look into the following examples included in the test directory:</p>
<ul>
<li>vortex-file-transfer-client.c</li>
<li>vortex-file-transfer-server.c</li>
</ul>
<h2><a class="anchor" id="vortex_manual_http_support">
4.4 Doing BEEP connections through HTTP proxy servers</a></h2>
<p>In many cases a BEEP client will require to connect to a BEEP server which is outside the local area network and that network is limited by a firewall that constrains all internet connection, only allowing HTTP/HTTPS connections if they are done through the local proxy.</p>
<p>By using a mecanism provided by the HTTP protocol, the CONNECT method, a vortex client can connect to a remote BEEP server. This is done by using the following function:</p>
<ul>
<li><a class="el" href="group__vortex__http_ga81c5a4c79bbf547491292ea27e8d09a3.html#ga81c5a4c79bbf547491292ea27e8d09a3">vortex_http_connection_new</a></li>
</ul>
<p>Previous function will create a connection to a target BEEP host, using proxy settings defined by <a class="el" href="group__vortex__http_ga4411fad3ad6ae781d9917fa477665804.html#ga4411fad3ad6ae781d9917fa477665804">VortexHttpSetup</a>. The connection returned will work in the same way (with no difference) as the ones returned by <a class="el" href="group__vortex__connection_ga727b938695d1037058256e3559d9d599.html#ga727b938695d1037058256e3559d9d599">vortex_connection_new</a>.</p>
<h2><a class="anchor" id="vortex_manual_pull_api">
4.5 PULL API single thread event notification</a></h2>
<p>Vortex Library design is heavily threaded. In some cases due to programing approach or environment conditions it is required a single threaded API where a single loop can handle all async events (frame received, connection received, etc).</p>
<p>This API will allow the programmer to not receive async notifications but pull them (<a class="el" href="group__vortex__pull_ga7b3616657fa673d8deefd02dce2404b3.html#ga7b3616657fa673d8deefd02dce2404b3">vortex_pull_next_event</a>).</p>
<p>Each call to pull an event returns an <a class="el" href="group__vortex__pull_ga192754cba5255e771a2b58c0ca0434ae.html#ga192754cba5255e771a2b58c0ca0434ae">VortexEvent</a> object which includes the event type (<a class="el" href="group__vortex__pull_ga4e20fbe5e2826ee0a1b3dc756bc75d6e.html#ga4e20fbe5e2826ee0a1b3dc756bc75d6e">vortex_event_get_type</a>) that guides the user to fetch for particular event data associated according to its type.</p>
<p>For example, if <a class="el" href="group__vortex__pull_ga4e20fbe5e2826ee0a1b3dc756bc75d6e.html#ga4e20fbe5e2826ee0a1b3dc756bc75d6e">vortex_event_get_type</a> returns <a class="el" href="group__vortex__pull_gada952eea76fc8f6a10323e194a811671.html#ggada952eea76fc8f6a10323e194a811671a7a98258ff9c5aa682f40209d0ab9ea89">VORTEX_EVENT_FRAME_RECEIVED</a> the programmer should call to <a class="el" href="group__vortex__pull_ga7500894ee7c451dd5dfe2ef5ebb29a45.html#ga7500894ee7c451dd5dfe2ef5ebb29a45">vortex_event_get_channel</a> to get the channel where the frame was received and to call to <a class="el" href="group__vortex__pull_gaeed7fae79ffed780482d9d4ae8e39d9d.html#gaeed7fae79ffed780482d9d4ae8e39d9d">vortex_event_get_frame</a> to get a reference to the frame received.</p>
<p><b>4.5.1 PULL API activation:</b></p>
<p>Before using PULL event, it is required to activate the API. See <a class="el" href="group__vortex__pull_gaf920e30383a9e65aa347b25b7eda3a0c.html#gaf920e30383a9e65aa347b25b7eda3a0c">vortex_pull_init</a> for details on this.</p>
<p><b>4.5.2 PULLing events:</b></p>
<p>You must use <a class="el" href="group__vortex__pull_ga7b3616657fa673d8deefd02dce2404b3.html#ga7b3616657fa673d8deefd02dce2404b3">vortex_pull_next_event</a> to get the next pending event. If no pending event available the function will block the caller until new events arrive.</p>
<p>Use <a class="el" href="group__vortex__pull_gac3297410692a6f81cd6377ecb365a2cd.html#gac3297410692a6f81cd6377ecb365a2cd">vortex_pull_pending_events</a> to check if there are pending events before calling to <a class="el" href="group__vortex__pull_ga7b3616657fa673d8deefd02dce2404b3.html#ga7b3616657fa673d8deefd02dce2404b3">vortex_pull_next_event</a>.</p>
<p><b>4.5.3 Event masking: how avoid receiving some events.</b></p>
<p>You can create a <a class="el" href="group__vortex__pull_gabbe9fa0de0f88ea9625cf816b93be787.html#gabbe9fa0de0f88ea9625cf816b93be787">VortexEventMask</a> that configures a set of events to be ignored. Keep in mind that ignoring events may activate default action associated.</p>
<p>For example, disabling <a class="el" href="group__vortex__pull_gada952eea76fc8f6a10323e194a811671.html#ggada952eea76fc8f6a10323e194a811671a5c18d29382e595057926069d3ba7ef9c">VORTEX_EVENT_CHANNEL_START</a> will cause to accept all channel start request received.</p>
<p><em><b>NOTE:</b> Default action associated to each particular event is described either by the event documentation or by the default action taken by the async handler that the event represents. Check documentation.</em></p>
<p><b>4.5.4 Can I use select(2) or poll(2) system call to watch sockets for changes rather than using <a class="el" href="group__vortex__pull_ga7b3616657fa673d8deefd02dce2404b3.html#ga7b3616657fa673d8deefd02dce2404b3">vortex_pull_next_event</a>?</b></p>
<p>It is possible but you have to consider that changes notified at the socket level may not produce a fetchable event (<a class="el" href="group__vortex__pull_ga7b3616657fa673d8deefd02dce2404b3.html#ga7b3616657fa673d8deefd02dce2404b3">vortex_pull_next_event</a>). This is because there is a period between a change is detected at the socket level and the time vortex engine takes for processing incoming information so it can emit an event.</p>
<p>Keep also in mind that some events may not depend on socket traffic. For example <a class="el" href="group__vortex__pull_gada952eea76fc8f6a10323e194a811671.html#ggada952eea76fc8f6a10323e194a811671a435736f62ed710cfc67128272158599d">VORTEX_EVENT_CHANNEL_REMOVED</a> is emited when a channel is removed from a connection. For example, having a connection closed suddently will make to emit a <a class="el" href="group__vortex__pull_gada952eea76fc8f6a10323e194a811671.html#ggada952eea76fc8f6a10323e194a811671a435736f62ed710cfc67128272158599d">VORTEX_EVENT_CHANNEL_REMOVED</a> for each channel found.</p>
<p><em>In any case <b>it is recommended to use</b> <a class="el" href="group__vortex__pull_gac3297410692a6f81cd6377ecb365a2cd.html#gac3297410692a6f81cd6377ecb365a2cd">vortex_pull_pending_events</a> <b>before calling to</b> <a class="el" href="group__vortex__pull_ga7b3616657fa673d8deefd02dce2404b3.html#ga7b3616657fa673d8deefd02dce2404b3">vortex_pull_next_event</a> to avoid blocking.</em></p>
<p><b>The recommended approach</b> is is to check for pending events and pull them on idle loops or to just get blocked on <a class="el" href="group__vortex__pull_ga7b3616657fa673d8deefd02dce2404b3.html#ga7b3616657fa673d8deefd02dce2404b3">vortex_pull_next_event</a>.</p>
<h2><a class="anchor" id="vortex_manual_alive_api">
4.6 ALIVE API, active checks for connection status</a></h2>
<p>Vortex ALIVE API is an extension (optional) library that can be used to improve connection alive checks and notifications produced by <a class="el" href="group__vortex__connection_ga9e24cab1e89fe826bb079a161cdd981f.html#ga9e24cab1e89fe826bb079a161cdd981f">vortex_connection_set_on_close_full</a>.</p>
<p>Currently, connection close notification is only received when an active connection close was done either at the local or the remote peer. However, in the case the connection becomes unavailable because network unplug or because the remote peer has poweroff, or because the remote peer application is hanged, this causes the connection close to be not triggered until the TCP timeout is reached.</p>
<p>In this case, ALIVE check can be used to enforce a transparent and active check implemented on top of a simply MSG/RPY where, if reached some amount of unreplied messages, a connection close is triggered, causing the code configured at <a class="el" href="group__vortex__connection_ga9e24cab1e89fe826bb079a161cdd981f.html#ga9e24cab1e89fe826bb079a161cdd981f">vortex_connection_set_on_close_full</a> to be called.</p>
<p>To enable the check, the receiver must accept be "checked" by the remote peer. This is done by calling:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// enable receiving alive checks from any peer </span>
 <a class="code" href="group__vortex__alive_ga80c54646203117ff600c653bc9a40cf8.html#ga80c54646203117ff600c653bc9a40cf8" title="Allows to init alive module on the current context.">vortex_alive_init</a> ();
</pre></div><p>Now, at the watching side (my be the listener or the initiator), you have to do the following to enable checking on the connection:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> (! <a class="code" href="group__vortex__alive_ga969e3e2d9c11dd7466e9bf417798543b.html#ga969e3e2d9c11dd7466e9bf417798543b" title="Allows to enable alive supervision on the provided connection.">vortex_alive_enable_check</a> (conn, check_period, unreply_count, NULL)) {
      <span class="comment">// failed to enable check </span>
 } 
</pre></div><p>This will enable a period check (defined by check_period) and will trigger a connection close in the case it is found that unreplied count reaches unreply_count.</p>
<p><b>NOTES:</b></p>
<ul>
<li>The check is implemented using a simply MSG/RPY protocol as discussed in previous mails.</li>
</ul>
<ul>
<li>The check can be enabled at any time.</li>
</ul>
<ul>
<li>The check will trigger a connection, allowing to reuse all connection close code already configured.</li>
</ul>
<ul>
<li>It is not required to do anything to remove the check after a connection was closed. This is done automatically.</li>
</ul>
<ul>
<li>If it is required to enable check in both directions, the same reverse steps must be done.</li>
</ul>
<p>To use alive API, you must include the header: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;vortex_alive.h&gt;</span>
</pre></div><p>And to add a link flag to use <b>libvortex-alive-1.1.dll</b>. In case of Linux/Unix you can use <b>-lvortex-alive-1.1</b> or:</p>
<div class="fragment"><pre class="fragment"> &gt;&gt; pkg-config --libs vortex-aliave-1.1
</pre></div><h2><a class="anchor" id="vortex_manual_feeder_api">
4.7 How to use feeder API (streaming and transfering files efficiently)</a></h2>
<p>The usual pattern to send content is to issue a MSG frame (no matter its size) using <a class="el" href="group__vortex__channel_ga69167b79eaca52375ced805c13125cd8.html#ga69167b79eaca52375ced805c13125cd8">vortex_channel_send_msg</a> (or similar functions) or replying to an incoming MSG sending content in the form of a RPY frame or a series of ANS frames ended by a NUL frame.</p>
<p>While this approach is the most suitable for small and unknown sizes, it becomes a problem if we want to do continus transfer or just send a huge file.</p>
<p>This is because every message we send with vortex, it is copied into its internal structures so the caller is not blocked (nice feature) and at the sime time it is allowed to release the content right after returning from the send function. Obviously this is a problem that grows with the size of the content to be transferred.</p>
<p>Here is where the payload feeder API can be used to feed content directly into the vortex sequencer (the vortex private thread in charge of sending all pending content) without allocating it and feeding the content with the optimal sizes at the right time.</p>
<p>The <a class="el" href="group__vortex__payload__feeder.html">feeder API</a> is built on top of the <a class="el" href="group__vortex__types_ga10528ca712a25756d4d399bcc8db524b.html#ga10528ca712a25756d4d399bcc8db524b">VortexPayloadFeeder</a> type which encapsulates a handler defined by the user that must react and complete a set of events issued by the vortex sending engine.</p>
<p>On top of this feeder API, it is already implemented a feeder to read the content from a file, and stream it into vortex. Here is how to use it:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__vortex__types_ga10528ca712a25756d4d399bcc8db524b.html#ga10528ca712a25756d4d399bcc8db524b" title="Type used to represent a payload feeder.">VortexPayloadFeeder</a> * feeder;

 <span class="comment">// create the feeder configured to read content from a file </span>
 feeder = <a class="code" href="group__vortex__payload__feeder_ga10a2e35f27b2ae4adb5ec7773fa9e053.html#ga10a2e35f27b2ae4adb5ec7773fa9e053" title="Creates a feeder object connected to the file found at the path provided.">vortex_payload_feeder_file</a> (FILE_TO_TRANSFER, axl_false);

 <span class="comment">// use the feeder to issue a RPY frame</span>
 <span class="keywordflow">if</span> (! <a class="code" href="group__vortex__channel_ga31c3c94341a8b00aa88ead08b03ae04d.html#ga31c3c94341a8b00aa88ead08b03ae04d" title="Allowsto send a RPY message in reply to the provided msg_no_rpy, using a feeder to...">vortex_channel_send_rpy_from_feeder</a> (channel, feeder, <a class="code" href="group__vortex__frame_ga0ecac42a92d4a585a068c99bb63529dc.html#ga0ecac42a92d4a585a068c99bb63529dc" title="Return current message number used for the given frame.">vortex_frame_get_msgno</a> (frame))) {
     printf (<span class="stringliteral">&quot;ERROR: failed to send RPY using feeder..\n&quot;</span>);
     <span class="keywordflow">return</span>;
 } 
</pre></div><p>In the case you want to feed content directly from a database or a socket, etc, you can take a look on how it is implemented <a class="el" href="group__vortex__payload__feeder_ga10a2e35f27b2ae4adb5ec7773fa9e053.html#ga10a2e35f27b2ae4adb5ec7773fa9e053">vortex_payload_feeder_file</a> to create the appropriate handler that implements your needs and then call to <a class="el" href="group__vortex__payload__feeder_ga7437f0cd215540588fae85aed3967a3f.html#ga7437f0cd215540588fae85aed3967a3f">vortex_payload_feeder_new</a> to create a feeder object governed by that handler.</p>
<h2><a class="anchor" id="vortex_manual_securing_your_session">
5.1 Securing a Vortex Connection (or How to use the TLS profile)</a></h2>
<p>The main advantage the BEEP protocol has is that it solves many common problems that the network protocol designer will have to face while designing an application protocol. Securing a connection to avoid other parties to access data exchanged by BEEP peers is one of them.</p>
<p>The idea behind the TLS profile is to enable user level applications to activate the TLS profile for a given session and then create channels, exchange data, etc. Inside Vortex Library, the is no difference about using a <a class="el" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4">connection</a> that is secured from one that is not.</p>
<p>Common scenario for a Vortex Library client application is:</p>
<ul>
<li>1. Create a connection to a remote peer using <a class="el" href="group__vortex__connection_ga727b938695d1037058256e3559d9d599.html#ga727b938695d1037058256e3559d9d599">vortex_connection_new</a>.</li>
</ul>
<ul>
<li>2. Secure the connection already created using <a class="el" href="group__vortex__tls_gaa1e4243a5e9de386d8230edafcfad021.html#gaa1e4243a5e9de386d8230edafcfad021">vortex_tls_start_negotiation</a>.</li>
</ul>
<ul>
<li>3. Then use the <a class="el" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4">connection</a>, as usual, creating channels (<a class="el" href="group__vortex__channel_ga4e6c15b9779b73be703ea29f5d309085.html#ga4e6c15b9779b73be703ea29f5d309085">vortex_channel_new</a>), sending data over them (<a class="el" href="group__vortex__channel_ga69167b79eaca52375ced805c13125cd8.html#ga69167b79eaca52375ced805c13125cd8">vortex_channel_send_msg</a>), etc. From the application programmer's point of view there is no difference from using a connection secured to one that is not.</li>
</ul>
<p>For the TLS profile listener side, we have two possibilities:</p>
<ol>
<li>
<p class="startli"><b>Use predefined handlers provided by the Vortex to activate listener TLS profile support.</b></p>
<p>This is a cheap-effort option because the library comes with a test certificate and a test private key that are used in the case that location handlers for such files are not provided.</p>
<p>This enables starting developing the whole system and later, in the production environment, create a private key and a certificate and define needed handlers to locate them.</p>
<p>In this case, we could activate listener TLS profile support as follows: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// activate TLS profile support using defaults</span>
 <a class="code" href="group__vortex__tls_ga331c84ef581a5652b90d025f565fc633.html#ga331c84ef581a5652b90d025f565fc633" title="Allows to configure if the provided Vortex context will accept TLS incoming connections...">vortex_tls_accept_negotiation</a> (ctx,   <span class="comment">// context to configure</span>
                                NULL,  <span class="comment">// accept all TLS request received</span>
                                NULL,  <span class="comment">// use default certificate file</span>
                                NULL); <span class="comment">// use default private key file</span>
</pre></div><p><b>NOTE:</b> This option is highly not recommended on production environment because the private key and certificate file are public!</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Define all handlers required, especially those providing the certificate file and the private key file:</b></p>
<p class="endli">In this case: </p>
<ul>
<li>
<p class="startli">A <a class="el" href="group__vortex__tls_ga7aa743e27ab17360a2446678b8a92344.html#ga7aa743e27ab17360a2446678b8a92344">VortexTlsAcceptQuery</a> handler should be defined to control if an incoming TLS requests is accepted. Here is an example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// return axl_true if we agree to accept the TLS negotiation</span>
 axl_bool      check_and_accept_tls_request (<a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection, 
                                             <span class="keywordtype">char</span>             * serverName)
 {
     <span class="comment">// perform some special operations against the serverName</span>
     <span class="comment">// value or the received connection, return axl_false to deny the </span>
     <span class="comment">// TLS request, or axl_true to allow it.</span>
     
     <span class="keywordflow">return</span> axl_true;  
 }
</pre></div> <p class="endli"></p>
</li>
<li>
<p class="startli">A <a class="el" href="group__vortex__tls_ga3ab0af63b6d2b2ecdf48443220baba24.html#ga3ab0af63b6d2b2ecdf48443220baba24">VortexTlsCertificateFileLocator</a> handler should be defined to control which certificate file is to be used for each connection. Here is an example: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">char</span> * certificate_file_location (<a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection, 
                                   <span class="keywordtype">char</span>             * serverName)
 {
     <span class="comment">// perform some special operation to choose which </span>
     <span class="comment">// certificate file to be used, then return it:</span>
    
     <span class="keywordflow">return</span> <a class="code" href="group__vortex__support_ga8777201f869012c0fe42c827432c5e44.html#ga8777201f869012c0fe42c827432c5e44" title="Allows to lookup for a file into the known vortex data file locations.">vortex_support_find_data_file</a> (ctx, <span class="stringliteral">&quot;myCertificate.cert&quot;</span>); 
 }
</pre></div><p>Please note the use of <a class="el" href="group__vortex__support_ga8777201f869012c0fe42c827432c5e44.html#ga8777201f869012c0fe42c827432c5e44">vortex_support_find_data_file</a> function which allows to write portable source code avoiding native-full-paths. <a class="el" href="group__vortex__support_ga8777201f869012c0fe42c827432c5e44.html#ga8777201f869012c0fe42c827432c5e44">Check out this document to know more about this.</a></p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A <a class="el" href="group__vortex__tls_ga233882f24b0caaffd07da52f6595d38c.html#ga233882f24b0caaffd07da52f6595d38c">VortexTlsPrivateKeyFileLocator</a> handler should be defined to control which private key file is to be used for each connection. Here is an example: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">char</span> * private_key_file_location (<a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection, 
                                   <span class="keywordtype">char</span>             * serverName)
 {
     <span class="comment">// perform some special operation to choose which </span>
     <span class="comment">// private key file to be used, then return it:</span>
    
     <span class="keywordflow">return</span> <a class="code" href="group__vortex__support_ga8777201f869012c0fe42c827432c5e44.html#ga8777201f869012c0fe42c827432c5e44" title="Allows to lookup for a file into the known vortex data file locations.">vortex_support_find_data_file</a> (ctx, <span class="stringliteral">&quot;myPrivateKey.pem&quot;</span>); 
 }
</pre></div> <p class="endli"></p>
</li>
<li>
<p class="startli">Now use previous handlers to configure how TLS profile is support for the current Vortex Library instance as follows:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// activate TLS profile support using defaults</span>
 <a class="code" href="group__vortex__tls_ga331c84ef581a5652b90d025f565fc633.html#ga331c84ef581a5652b90d025f565fc633" title="Allows to configure if the provided Vortex context will accept TLS incoming connections...">vortex_tls_accept_negotiation</a> (ctx,
                                check_and_accept_tls_request,
                                certificate_file_location,
                                private_key_file_locatin);
</pre></div><p><b> NOTE:</b> If some handler is not provided the default one will be used. Not providing one of the file locators handler (either certificate locator and private key locator) may cause to not work TLS profile.</p>
<p class="endli"></p>
</li>
</ul>
</li>
</ol>
<p>There is also an alternative approach, which provides more control to configure the TLS process. See <a class="el" href="group__vortex__tls_ga331c84ef581a5652b90d025f565fc633.html#ga331c84ef581a5652b90d025f565fc633">vortex_tls_accept_negotiation</a> for more information, especially <a class="el" href="group__vortex__tls_ga00461d1d4c09f208867c0f89ab359cc9.html#ga00461d1d4c09f208867c0f89ab359cc9">vortex_tls_set_ctx_creation</a> and <a class="el" href="group__vortex__tls_ga475b9d8efa81271d784091b21d165830.html#ga475b9d8efa81271d784091b21d165830">vortex_tls_set_default_ctx_creation</a>.</p>
<p>Now your listener is prepared to receive incoming connections and enable TLS on them. Next section provides information on how to produce a certificate and a private key to avoid using the default provided by Vortex Library. See next section.</p>
<h2><a class="anchor" id="vortex_manual_creating_certificates">
5.2 How to create a test certificate and a private key to be used by the TLS profile</a></h2>
<p>Now we have successfully configured the TLS profile for listener side we need to create a certificate/private key pair. Currently Vortex Library TLS support is built using <b>OpenSSL</b> (<a href="http://www.openssl.org">http://www.openssl.org</a>). This SSL toolkit comes with some tools to create such files. Here is an example to create a test certificate and a private key that can be used for testing purposes:</p>
<ol>
<li>
<p class="startli">Create a 1024 bits private key using:</p>
<div class="fragment"><pre class="fragment">  &gt;&gt; openssl genrsa 1024 &gt; test-<span class="keyword">private</span>.key
</pre></div> <p class="endli"></p>
</li>
<li>
<p class="startli">Now create the public certificate reusing previously created key as follows:</p>
<div class="fragment"><pre class="fragment">  &gt;&gt; openssl req -<span class="keyword">new</span> -x509 -nodes -sha1 -days 3650 -key test-<span class="keyword">private</span>.key &gt; test-certificate.crt
</pre></div> <p class="endli"></p>
</li>
<li>
Once finished, you can check certificate data using: <div class="fragment"><pre class="fragment">  &gt;&gt; openssl x509 -noout -fingerprint -text &lt; test-certificate.crt
</pre></div>  </li>
</ol>
<h2><a class="anchor" id="vortex_manual_using_sasl">
5.3 Authenticating BEEP peers (or How to use SASL profiles family)</a></h2>
<p>While using or designing network protocols, a common issue to solve and support is to identify and authenticate users on top of it. This security issue is supported inside BEEP through SASL profiles.</p>
<p>SASL (RFC2222) is a security framework which defines how security protocols are implemented so the same program structure could take advantage no matter which security protocol is being used.</p>
<p>SASL (Simple Authentication and Security Layer) provides not only a way to identify users but also to secure connections. At this moment, SASL implementation inside Vortex Library only provides authentication (that is the authentication part of SASL).</p>
<p>This is not a big problem knowing that TLS profile could be enabled, making the connection secure (providing the security layer) and then negotiate user identification (and its authorization) using SASL.</p>
<p>Again, the idea behind this is to design your application protocol without taking into account details such as: how to ensure that the protocol session is secure and who is the user at the other side of the peer using the protocol.</p>
<p>Currently these are the SASL profiles implemented and tested inside Vortex Library: </p>
<ul>
<li>
<p class="startli"><a class="el" href="group__vortex__sasl_ga1356b366f7bd5e3f8e5e1c23e1eea022.html#ga1356b366f7bd5e3f8e5e1c23e1eea022">ANONYMOUS</a> (<a class="el" href="group__vortex__sasl_ga1356b366f7bd5e3f8e5e1c23e1eea022.html#ga1356b366f7bd5e3f8e5e1c23e1eea022">VORTEX_SASL_ANONYMOUS</a>): provides a way to perform anonymous login providing an anonymous token to track the session. This profile does not provide authentication. However, server side authentication could also implement anonymous acceptance according to some selected anonymous logins that are recognized. This SASL profile works like anonymous FTP login does. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="group__vortex__sasl_ga84a86f85016c294702308def8aab6ccc.html#ga84a86f85016c294702308def8aab6ccc">PLAIN</a> (<a class="el" href="group__vortex__sasl_ga84a86f85016c294702308def8aab6ccc.html#ga84a86f85016c294702308def8aab6ccc">VORTEX_SASL_PLAIN</a>): provides support to perform login into a BEEP server providing a user and a password. Optionally, this SASL profile also support to provide an authorization identification. This is used to perform a login request as user <b>bob</b> but requesting to act as <b>alice</b>.</p>
<p>This SASL profile works as people usually expect: client side provides a user identification (for example: <b>bob</b>) and a password (for example: <b>secret</b>). Then, server side receive these values and decide to allow or to deny SASL authentication according to the internal user database state.</p>
<p>This SASL profile exchange user and password data in clear text. This is insecure because a third party could intercept your TCP session and read sensible information. To use this profile it is recommended to activate <a class="el" href="starting__to__program.html#vortex_manual_securing_your_session">the TLS profile</a> or any other external mechanism such as IPSec.</p>
<p>Advantages of this SASL profile are:</p>
<ul>
<li>
<p class="startli">It is faster than its brothers-in-features: <a class="el" href="group__vortex__sasl_ga538d96c8efadcc59dac0adfed9b5c01e.html#ga538d96c8efadcc59dac0adfed9b5c01e">CRAM-MD5</a> and <a class="el" href="group__vortex__sasl_gabe035e4448549d77ee23269977b0dfa1.html#gabe035e4448549d77ee23269977b0dfa1">DIGEST-MD5</a> and ..</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">It is the only way to support systems where user/password pair is not stored in clear-text. This is because this is the only one SASL profile which actually sends the user/password pair in clear text, allowing to the server side to apply them the corresponding cryptographic method and compare it with the ciphered stored value.</p>
<p>Database oriented applications usually store passwords using MD5 or other hashing method, making necessary to have the clear text version for the password (and maybe, but not usually, the user).</p>
<p class="endli"></p>
</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><a class="el" href="group__vortex__sasl_ga538d96c8efadcc59dac0adfed9b5c01e.html#ga538d96c8efadcc59dac0adfed9b5c01e">CRAM-MD5</a> (<a class="el" href="group__vortex__sasl_ga538d96c8efadcc59dac0adfed9b5c01e.html#ga538d96c8efadcc59dac0adfed9b5c01e">VORTEX_SASL_CRAM_MD5</a>): From the programmer's point of view, this SASL profile is implemented in the same way that <a class="el" href="group__vortex__sasl_ga84a86f85016c294702308def8aab6ccc.html#ga84a86f85016c294702308def8aab6ccc">PLAIN</a> but underlying SASL negotiation is more secure. This is because CRAM-MD5 handshake definition does not require to transfer clear user and password but a hashed version of it.</p>
<p>Server side generates a hash token, that is used only for the given SASL negotiation, and sends it the client. Then, client side use this hash to create a new hash token as a result to apply it to the users password. Then, this result is sent to the server.</p>
<p>At this point, a malicious third party only could read a hash version that only have meaning for the server side. Then, server side requires from the application level to provide the password for the user selected hashing it with the initially created hash, comparing the result with received hash from the client.</p>
<p>If the previous two hashes match, then the SASL authentication is done. This is roughly how CRAM-MD5 works.</p>
<p>This SASL profile is preferred over PLAIN because it is more secure and can be used over non-secured connections. However, it is slow than PLAIN because requires computational operations such as hashing. This could impact at the number of successful logins that could provide the system designed.</p>
<p>Another question to take into account is that this SASL profile does not provide a way to provide a user identification and act as another user like PLAIN does.</p>
<p>Because this SASL profile is more secure than PLAIN, it could be used without having negotiated an underlying security layer.</p>
<p>One disadvantage this profile have (and <a class="el" href="group__vortex__sasl_gabe035e4448549d77ee23269977b0dfa1.html#gabe035e4448549d77ee23269977b0dfa1">DIGEST-MD5</a>) is that server application must have access to clear text passwords. This is because it is needed to produce a hashed version (including the user) to compare it to the hash received from the client side.</p>
<p>Obviously, this is not possible in many cases, starting from those applications based on SQL (or any other back end) which stores passwords using MD5 (or any other password cipher method). In this case, application designers could use PLAIN profile on top of <a class="el" href="starting__to__program.html#vortex_manual_securing_your_session">TLS profile</a>.</p>
<p><em><b>NOTE: </b> It seems that this SASL profile is deprecated in favor of DIGEST-MD5. The only reason that I've found is that DIGEST-MD5 provides the same features like CRAM-MD5 but with a stronger cipher. However, I found <b>DIGEST-MD5</b> 2 times slower, and requiring some SASL properties such as the realm, that doesn't fit into the common network application design.</em></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><a class="el" href="group__vortex__sasl_gabe035e4448549d77ee23269977b0dfa1.html#gabe035e4448549d77ee23269977b0dfa1">DIGEST-MD5</a> (<a class="el" href="group__vortex__sasl_gabe035e4448549d77ee23269977b0dfa1.html#gabe035e4448549d77ee23269977b0dfa1">VORTEX_SASL_DIGEST_MD5</a>): This SASL profile have some interesting features over the previous one. As starting point, the profile implements the same hash-exchange concept like CRAM-MD5 does for authenticating users. However, the cipher used is stronger and it also support login as a user and request acting as another.</p>
<p>Additionally, this SASL profile provides not only authentication but also security layer. However, it is not supported mainly because SASL implementation used does not support it and because security layer is already provided by TLS profile.</p>
<p>This SASL profile not only requires to provide a user and a password, but also to provide the realm where the selected user will be authenticated. </p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="group__vortex__sasl_gaebd393219bc920f19f3b64543d2e673d.html#gaebd393219bc920f19f3b64543d2e673d">EXTERNAL</a> (<a class="el" href="group__vortex__sasl_gaebd393219bc920f19f3b64543d2e673d.html#gaebd393219bc920f19f3b64543d2e673d">VORTEX_SASL_EXTERNAL</a>): This profile is provided to support changing SASL state to authenticated for those environments where underlying session already ensures authentication.  </li>
</ul>
<h2><a class="anchor" id="vortex_manual_sasl_for_client_side">
5.4 How to use SASL at the client side</a></h2>
<p>Now you have an overview for SASL profiles supported here is how to use them.</p>
<p>Vortex Library SASL implementation uses for the client side (the BEEP peer that wants to be authenticated) <a class="el" href="group__vortex__sasl_ga06a73827b11b7c725c7cb6c1e5269d8f.html#ga06a73827b11b7c725c7cb6c1e5269d8f">vortex_sasl_set_propertie</a> and then <a class="el" href="group__vortex__sasl_gac08c6b7f98cbed7e50e10f6a9e1fe2d3.html#gac08c6b7f98cbed7e50e10f6a9e1fe2d3">vortex_sasl_start_auth</a> to begin SASL negotiation.</p>
<p>With <a class="el" href="group__vortex__sasl_ga06a73827b11b7c725c7cb6c1e5269d8f.html#ga06a73827b11b7c725c7cb6c1e5269d8f">vortex_sasl_set_propertie</a> you set the values required by the process such as: the user and its password. Once all values required are set a call to <a class="el" href="group__vortex__sasl_gac08c6b7f98cbed7e50e10f6a9e1fe2d3.html#gac08c6b7f98cbed7e50e10f6a9e1fe2d3">vortex_sasl_start_auth</a> is done to activate SASL layer.</p>
<p>Every SASL profile requires different properties to be set. Some of them are optional and some of them are common to all profiles.</p>
<p>Let's start with an example on how to CRAM-MD5 profile to authenticate a client peer:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__vortex__types_ga25d85d2d28e8808a03b003e13c452e17.html#ga25d85d2d28e8808a03b003e13c452e17" title="Vortex Operation Status.">VortexStatus</a>    status;
 <span class="keywordtype">char</span>          * status_message;
 
 <span class="comment">// STEP 1: check if SASL is activated for the given Vortex Library</span>
 <span class="keywordflow">if</span> (! vortex_sasl_is_enabled ()) {
      <span class="comment">// unable to activate SASL profile. This only happens when</span>
      <span class="comment">// Vortex Library wasn&#39;t built with SASL support</span>
      printf (<span class="stringliteral">&quot;Unable to initialize SASL profiles.\n&quot;</span>);
 }
 
 <span class="comment">// STEP 2: set required properties according to SASL profile selected</span>
 <span class="comment">// set user to authenticate</span>
 <a class="code" href="group__vortex__sasl_ga06a73827b11b7c725c7cb6c1e5269d8f.html#ga06a73827b11b7c725c7cb6c1e5269d8f" title="Allows to configure SASL properties used for the SASL authentication process.">vortex_sasl_set_propertie</a> (connection, <a class="code" href="group__vortex__sasl_gab991fbe01cecb91bf18f4a403d7131a8.html#ggab991fbe01cecb91bf18f4a403d7131a8aa2f7856cc29fafc03e6cecf019082a86" title="User identifier to be used while SASL negotiation is running.">VORTEX_SASL_AUTH_ID</a>, <span class="stringliteral">&quot;bob&quot;</span>, NULL);

 <span class="comment">// set the password</span>
 <a class="code" href="group__vortex__sasl_ga06a73827b11b7c725c7cb6c1e5269d8f.html#ga06a73827b11b7c725c7cb6c1e5269d8f" title="Allows to configure SASL properties used for the SASL authentication process.">vortex_sasl_set_propertie</a> (connection, <a class="code" href="group__vortex__sasl_gab991fbe01cecb91bf18f4a403d7131a8.html#ggab991fbe01cecb91bf18f4a403d7131a8aa7682fe7eddd224fbed7e852fe077341" title="User password to be used while SASL negotiation is running.">VORTEX_SASL_PASSWORD</a>, <span class="stringliteral">&quot;secret&quot;</span>, NULL);
 
 <span class="comment">// STEP 3: begin SASL negotiation</span>
 <a class="code" href="group__vortex__sasl_ga97b92c98149ce612d5c4ccd9248cdaf2.html#ga97b92c98149ce612d5c4ccd9248cdaf2" title="Perform SASL negotiation in a synchronous mode (blocking the caller until process...">vortex_sasl_start_auth_sync</a> (<span class="comment">// the connection where SASL will take place</span>
                              connection, 
                              <span class="comment">// SASL profile selected</span>
                              <a class="code" href="group__vortex__sasl_ga538d96c8efadcc59dac0adfed9b5c01e.html#ga538d96c8efadcc59dac0adfed9b5c01e" title="CRAM-MD5 profile identification to be used at vortex_sasl_start_auth or vortex_sasl_accept_negotiati...">VORTEX_SASL_CRAM_MD5</a>,
                              <span class="comment">// SASL status variables</span>
                              &amp;status, &amp;status_message);

 <span class="comment">// STEP 4: once finished, check of authentication</span>
 <span class="keywordflow">if</span> (<a class="code" href="group__vortex__sasl_ga388e2740c4599823205d2f3fa509f598.html#ga388e2740c4599823205d2f3fa509f598" title="Allows to check if the given connection have been successfully authenticated.">vortex_sasl_is_authenticated</a> (connection)) {
      printf (<span class="stringliteral">&quot;SASL negotiation OK, user %s is authenticated\n&quot;</span>,
               <a class="code" href="group__vortex__sasl_gadd0de03529e7171917ed45c1ae375750.html#gadd0de03529e7171917ed45c1ae375750" title="Allows to get current SASL properties from the given connection.">vortex_sasl_get_propertie</a> (connection, <a class="code" href="group__vortex__sasl_gab991fbe01cecb91bf18f4a403d7131a8.html#ggab991fbe01cecb91bf18f4a403d7131a8aa2f7856cc29fafc03e6cecf019082a86" title="User identifier to be used while SASL negotiation is running.">VORTEX_SASL_AUTH_ID</a>));
 }<span class="keywordflow">else</span> {
      printf (<span class="stringliteral">&quot;SASL negotiation have failed: status=%d, message=%s\n&quot;</span>,
               status, message);
 }
 <span class="comment">// roughly, that&#39;s all for the client side</span>
</pre></div><p>Previous code will look the same for all SASL profile selected. The only part that will change will be properties provided (that are required by the SASL profile <b>STEP 2</b>).</p>
<p>On <b>step 3</b> <a class="el" href="group__vortex__sasl_ga97b92c98149ce612d5c4ccd9248cdaf2.html#ga97b92c98149ce612d5c4ccd9248cdaf2">vortex_sasl_start_auth_sync</a> is used to perform SASL negotiation. This function is the blocking version for <a class="el" href="group__vortex__sasl_gac08c6b7f98cbed7e50e10f6a9e1fe2d3.html#gac08c6b7f98cbed7e50e10f6a9e1fe2d3">vortex_sasl_start_auth</a>. Synchronous version is only recommended for bath process because the caller get blocked until SASL profile finish. However it is easy to explain SASL function inside Vortex using synchronous version.</p>
<p>Asynchronous version (through <a class="el" href="group__vortex__sasl_gac08c6b7f98cbed7e50e10f6a9e1fe2d3.html#gac08c6b7f98cbed7e50e10f6a9e1fe2d3">vortex_sasl_start_auth</a>) is preferred because allows to perform other tasks (like updating GUI interfaces) while SASL negotiation is running.</p>
<p>Here is a table with properties that are required (or are optional) for each SASL profile used.</p>
<table class="doxtable">
<tr>
<td></td><td><b>ANONYMOUS</b></td><td><b>PLAIN</b></td><td><b>CRAM-MD5</b></td><td><b>DIGEST-MD5</b></td><td><b>EXTERNAL</b> </td></tr>
<tr>
<td><b>VORTEX_SASL_AUTH_ID</b></td><td></td><td>required</td><td>required</td><td>required</td><td></td></tr>
<tr>
<td><b>VORTEX_SASL_AUTHORIZATION_ID</b></td><td></td><td>optional</td><td></td><td>optional</td><td>required </td></tr>
<tr>
<td><b>VORTEX_SASL_PASSWORD</b></td><td></td><td>required</td><td>required</td><td>required</td><td></td></tr>
<tr>
<td><b>VORTEX_SASL_REALM</b></td><td></td><td></td><td></td><td>required</td><td></td></tr>
<tr>
<td><b>VORTEX_SASL_ANONYMOUS_TOKEN</b></td><td>required</td><td></td><td></td><td></td><td></td></tr>
</table>
<h2><a class="anchor" id="vortex_manual_sasl_for_server_side">
5.5 How to use SASL at the server side</a></h2>
<p>Well, as we have seeing in the previous section, SASL at the client side is entirely driven by properties (through <a class="el" href="group__vortex__sasl_ga06a73827b11b7c725c7cb6c1e5269d8f.html#ga06a73827b11b7c725c7cb6c1e5269d8f">vortex_sasl_set_propertie</a>). However at the server is SASL is entirely driven by call backs.</p>
<p>There is one callback for each SASL profile supported inside Vortex Library. They allow to your server application to connect SASL authentication process with legacy user/password databases.</p>
<p>Vortex Library supports, through SASL, transporting and authenticating users but, at the end, the programmer must provide the final decision to allow or to deny SASL authentication request.</p>
<p>Here is an example on how to activate PLAIN support and validate request received for this profile: </p>
<div class="fragment"><pre class="fragment"> [...] at some part of your program (likely to be at the main)
 <span class="comment">// check for SASL support</span>
 <span class="keywordflow">if</span> (!vortex_sasl_is_enabled ()) {
    <span class="comment">// drop a log about Vortex Library not supporting SASL</span>
    <span class="keywordflow">return</span> -1;
 }
 
 <span class="comment">// set default plain validation handler</span>
 <a class="code" href="group__vortex__sasl_gac6a5822129eb7d628ba640f5a1672c79.html#gac6a5822129eb7d628ba640f5a1672c79" title="Allows to set the validation handler to be used while authenticating PLAIN SASL profile...">vortex_sasl_set_plain_validation</a> (ctx, sasl_plain_validation);
 
 <span class="comment">// accept SASL PLAIN incoming requests</span>
 <span class="keywordflow">if</span> (! <a class="code" href="group__vortex__sasl_ga717127773aa2fc43ef5a2c8c7771277e.html#ga717127773aa2fc43ef5a2c8c7771277e" title="Allows to configure current Vortex Library process to accept incoming SASL negotiations...">vortex_sasl_accept_negotiation</a> (ctx, <a class="code" href="group__vortex__sasl_ga84a86f85016c294702308def8aab6ccc.html#ga84a86f85016c294702308def8aab6ccc" title="PLAIN profile identification to be used at vortex_sasl_start_auth or vortex_sasl_accept_negotiation...">VORTEX_SASL_PLAIN</a>)) {
        printf (<span class="stringliteral">&quot;Unable  accept SASL PLAIN profile&quot;</span>);
        <span class="keywordflow">return</span> -1;
 }
 [...]
 <span class="comment">// validation handler for SASL PLAIN profile</span>
 axl_bool      sasl_plain_validation  (<a class="code" href="group__vortex__types_gac16883b703d1e546d54108153d4060b4.html#gac16883b703d1e546d54108153d4060b4" title="A Vortex Connection object (BEEP session representation).">VortexConnection</a> * connection,
                                       <span class="keyword">const</span> <span class="keywordtype">char</span>       * auth_id,
                                       <span class="keyword">const</span> <span class="keywordtype">char</span>       * authorization_id,
                                       <span class="keyword">const</span> <span class="keywordtype">char</span>       * password)
 {

      <span class="comment">// At this point your server application should connect</span>
      <span class="comment">// to its internal user/password database to validate</span>
      <span class="comment">// incoming request. </span>
 
      <span class="comment">// In this case we perform a validation based on receiving</span>
      <span class="comment">// a pair based on bob/secret allowing it, and denying</span>
      <span class="comment">// the rest of user/password pairs.</span>

        <span class="keywordflow">if</span> (axl_cmp (auth_id, <span class="stringliteral">&quot;bob&quot;</span>) &amp;&amp; 
            axl_cmp (password, <span class="stringliteral">&quot;secret&quot;</span>)) {
              <span class="comment">// notify Vortex that the given SASL request</span>
              <span class="comment">// have been accepted by the application level.</span>
                <span class="keywordflow">return</span> axl_true;
        }
        <span class="comment">// deny SASL request to authenticate remote peer</span>
        <span class="keywordflow">return</span> axl_false;
 }
</pre></div><p>Previous example show the way to activate the SASL authentication support. First it is configured a handler to manage the authentication request, according to the SASL method desired. In this case the following function is used:</p>
<ul>
<li><a class="el" href="group__vortex__sasl_gac6a5822129eb7d628ba640f5a1672c79.html#gac6a5822129eb7d628ba640f5a1672c79">vortex_sasl_set_plain_validation</a></li>
</ul>
<p>Keep in mind that previous function doesn't allows to configure an user data pointer to be passed to the handler. If you require this you must use the extended API, which is called the same but appending "_full". In this case, the function to be used is:</p>
<ul>
<li><a class="el" href="group__vortex__sasl_ga890adf6a81a421bebf5abdaa9fc0b75a.html#ga890adf6a81a421bebf5abdaa9fc0b75a">vortex_sasl_set_plain_validation_full</a></li>
</ul>
<p>For every SASL mechanism supported by Vortex Library there are two functions to configure the validation handler and the extended validation handler.</p>
<p>Then, a call to register and activate the profile <a class="el" href="group__vortex__sasl_ga84a86f85016c294702308def8aab6ccc.html#ga84a86f85016c294702308def8aab6ccc">VORTEX_SASL_PLAIN</a> is done. This step will notify vortex profiles module that the selected SASL profile must be announced as supported, at the connection greetings, configuring all internal SASL handlers. In this case, the example is not providing an user data to the <a class="el" href="group__vortex__sasl_ga717127773aa2fc43ef5a2c8c7771277e.html#ga717127773aa2fc43ef5a2c8c7771277e">vortex_sasl_accept_negotiation</a> function. In the case that a user data is required, the following function must be used:</p>
<ul>
<li><a class="el" href="group__vortex__sasl_ga8403a3a6e23d741a4a2211172ee37874.html#ga8403a3a6e23d741a4a2211172ee37874">vortex_sasl_accept_negotiation_full</a></li>
</ul>
<p>Now the SASL PLAIN profile is fully activated and waiting for requests. Validating the rest of SASL profiles works the same way. Some of them requires to return <b>axl_true</b> or <b>axl_false</b> to <b>allow</b> or to <b>deny</b> received request, and other profiles requires to return the password for a given user or NULL to deny it.</p>
<p>Here is a table for each profile listing the profile activation function and its handler.</p>
<table class="doxtable">
<tr>
<td></td><td><b>Validation handler setting</b></td><td><b>Validation handler</b> </td></tr>
<tr>
<td><b>ANONYMOUS</b></td><td><a class="el" href="group__vortex__sasl_ga778895dc9c0e05e0501a3b1c7e5a238b.html#ga778895dc9c0e05e0501a3b1c7e5a238b">vortex_sasl_set_anonymous_validation</a></td><td><a class="el" href="group__vortex__sasl_gabced73277d0362967c883cde8ebc04b6.html#gabced73277d0362967c883cde8ebc04b6">VortexSaslAuthAnonymous</a> </td></tr>
<tr>
<td><b>ANONYMOUS</b></td><td><a class="el" href="group__vortex__sasl_gad1385a89a27c80ab00e47209738819fe.html#gad1385a89a27c80ab00e47209738819fe">vortex_sasl_set_anonymous_validation_full</a></td><td><a class="el" href="group__vortex__sasl_gae69bcdf6a5ad16da40ff4aa43d0c8cf7.html#gae69bcdf6a5ad16da40ff4aa43d0c8cf7">VortexSaslAuthAnonymousFull</a> </td></tr>
<tr>
<td><b>PLAIN</b></td><td><a class="el" href="group__vortex__sasl_gac6a5822129eb7d628ba640f5a1672c79.html#gac6a5822129eb7d628ba640f5a1672c79">vortex_sasl_set_plain_validation</a></td><td><a class="el" href="group__vortex__sasl_ga6f6919a40f122d9a34a8aba4729911b7.html#ga6f6919a40f122d9a34a8aba4729911b7">VortexSaslAuthPlain</a> </td></tr>
<tr>
<td><b>PLAIN</b></td><td><a class="el" href="group__vortex__sasl_ga890adf6a81a421bebf5abdaa9fc0b75a.html#ga890adf6a81a421bebf5abdaa9fc0b75a">vortex_sasl_set_plain_validation_full</a></td><td><a class="el" href="group__vortex__sasl_ga56813795ca245d65410b38155574c085.html#ga56813795ca245d65410b38155574c085">VortexSaslAuthPlainFull</a> </td></tr>
<tr>
<td><b>CRAM-MD5</b></td><td><a class="el" href="group__vortex__sasl_ga6e80da45bb81349fda17fcb39b172254.html#ga6e80da45bb81349fda17fcb39b172254">vortex_sasl_set_cram_md5_validation</a></td><td><a class="el" href="group__vortex__sasl_gae3d18b41187096393c1ab82b2b657d0c.html#gae3d18b41187096393c1ab82b2b657d0c">VortexSaslAuthCramMd5</a> </td></tr>
<tr>
<td><b>CRAM-MD5</b></td><td><a class="el" href="group__vortex__sasl_ga7673bc7d290a9d4744846e43194f13b7.html#ga7673bc7d290a9d4744846e43194f13b7">vortex_sasl_set_cram_md5_validation_full</a></td><td><a class="el" href="group__vortex__sasl_gae836a4fe563b29ea53837328f5bda9c0.html#gae836a4fe563b29ea53837328f5bda9c0">VortexSaslAuthCramMd5Full</a> </td></tr>
<tr>
<td><b>DIGEST-MD5</b></td><td><a class="el" href="group__vortex__sasl_ga58bd59d36eb0dc1b0270a2880dd3f6ee.html#ga58bd59d36eb0dc1b0270a2880dd3f6ee">vortex_sasl_set_digest_md5_validation</a></td><td><a class="el" href="group__vortex__sasl_ga54b5490b8b5c9470e86b59ceba628339.html#ga54b5490b8b5c9470e86b59ceba628339">VortexSaslAuthDigestMd5</a> </td></tr>
<tr>
<td><b>DIGEST-MD5</b></td><td><a class="el" href="group__vortex__sasl_ga76737fc38bb41ada0e46ff2a7f7d3c3d.html#ga76737fc38bb41ada0e46ff2a7f7d3c3d">vortex_sasl_set_digest_md5_validation_full</a></td><td><a class="el" href="group__vortex__sasl_ga7f9fc07b38b5d8aa095cc8060a988371.html#ga7f9fc07b38b5d8aa095cc8060a988371">VortexSaslAuthDigestMd5Full</a> </td></tr>
<tr>
<td><b>EXTERNAL</b></td><td><a class="el" href="group__vortex__sasl_ga0caf1e10458564d8b1c457d4897f02bd.html#ga0caf1e10458564d8b1c457d4897f02bd">vortex_sasl_set_external_validation</a></td><td><a class="el" href="group__vortex__sasl_ga8a318a6fd7709e4b97974dd662807cd7.html#ga8a318a6fd7709e4b97974dd662807cd7">VortexSaslAuthExternal</a> </td></tr>
<tr>
<td><b>EXTERNAL</b></td><td><a class="el" href="group__vortex__sasl_ga328d21acad133c4bbe701f098b928ba5.html#ga328d21acad133c4bbe701f098b928ba5">vortex_sasl_set_external_validation_full</a></td><td><a class="el" href="group__vortex__sasl_gadc602a18cc640414270518737360b70d.html#gadc602a18cc640414270518737360b70d">VortexSaslAuthExternalFull</a> </td></tr>
</table>
<p>Once the validation is done. You can use the following two functions to check authentication status for the connection in the future, commonly, at the frame receive handler. This allows you to authenticate, and then, at the frame receive handler check the authentication status (or at any other place of course).</p>
<ul>
<li><a class="el" href="group__vortex__sasl_ga388e2740c4599823205d2f3fa509f598.html#ga388e2740c4599823205d2f3fa509f598">vortex_sasl_is_authenticated</a></li>
<li><a class="el" href="group__vortex__sasl_ga1f94387ef3f9ac892685c912f0e97c69.html#ga1f94387ef3f9ac892685c912f0e97c69">vortex_sasl_auth_method_used</a></li>
</ul>
<p>The first function is really important, and should be used before any further check. This ensures you that you are managing an authenticated connection, and then you can call to the next function, <a class="el" href="group__vortex__sasl_ga1f94387ef3f9ac892685c912f0e97c69.html#ga1f94387ef3f9ac892685c912f0e97c69">vortex_sasl_auth_method_used</a>, to get the auth method that was used, and finally call to the following function to get the appropriate auth data:</p>
<ul>
<li><a class="el" href="group__vortex__sasl_gadd0de03529e7171917ed45c1ae375750.html#gadd0de03529e7171917ed45c1ae375750">vortex_sasl_get_propertie</a></li>
</ul>
<p>Here is an example about checking the auth status, and getting auth properties, at a frame receive handler: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// drop a log about the sasl properties </span>
 <span class="keywordflow">if</span> (<a class="code" href="group__vortex__sasl_ga388e2740c4599823205d2f3fa509f598.html#ga388e2740c4599823205d2f3fa509f598" title="Allows to check if the given connection have been successfully authenticated.">vortex_sasl_is_authenticated</a> (connection)) {
     <span class="comment">// check the connection to be authenticated before assuming anything </span>
     printf (<span class="stringliteral">&quot;The connection is authenticated, using the method: %s\n&quot;</span>, 
              <a class="code" href="group__vortex__sasl_ga1f94387ef3f9ac892685c912f0e97c69.html#ga1f94387ef3f9ac892685c912f0e97c69" title="Allows to get SASL method used to authenticate the connection.">vortex_sasl_auth_method_used</a> (connection));

     printf (<span class="stringliteral">&quot;Auth data provided: \n  authid=%s\n  authorization id=%s\n  password=%s\n  realm=%s\n  anonymous token=%s\n&quot;</span>,
              <a class="code" href="group__vortex__sasl_gadd0de03529e7171917ed45c1ae375750.html#gadd0de03529e7171917ed45c1ae375750" title="Allows to get current SASL properties from the given connection.">vortex_sasl_get_propertie</a> (connection, <a class="code" href="group__vortex__sasl_gab991fbe01cecb91bf18f4a403d7131a8.html#ggab991fbe01cecb91bf18f4a403d7131a8aa2f7856cc29fafc03e6cecf019082a86" title="User identifier to be used while SASL negotiation is running.">VORTEX_SASL_AUTH_ID</a>),
              <a class="code" href="group__vortex__sasl_gadd0de03529e7171917ed45c1ae375750.html#gadd0de03529e7171917ed45c1ae375750" title="Allows to get current SASL properties from the given connection.">vortex_sasl_get_propertie</a> (connection, <a class="code" href="group__vortex__sasl_gab991fbe01cecb91bf18f4a403d7131a8.html#ggab991fbe01cecb91bf18f4a403d7131a8aa2982283ff0967e729f47c2d598d7971" title="Inside SASL definition, there is support to authenticate as &amp;quot;bob&amp;quot; and act...">VORTEX_SASL_AUTHORIZATION_ID</a>),
              <a class="code" href="group__vortex__sasl_gadd0de03529e7171917ed45c1ae375750.html#gadd0de03529e7171917ed45c1ae375750" title="Allows to get current SASL properties from the given connection.">vortex_sasl_get_propertie</a> (connection, <a class="code" href="group__vortex__sasl_gab991fbe01cecb91bf18f4a403d7131a8.html#ggab991fbe01cecb91bf18f4a403d7131a8aa7682fe7eddd224fbed7e852fe077341" title="User password to be used while SASL negotiation is running.">VORTEX_SASL_PASSWORD</a>),
              <a class="code" href="group__vortex__sasl_gadd0de03529e7171917ed45c1ae375750.html#gadd0de03529e7171917ed45c1ae375750" title="Allows to get current SASL properties from the given connection.">vortex_sasl_get_propertie</a> (connection, <a class="code" href="group__vortex__sasl_gab991fbe01cecb91bf18f4a403d7131a8.html#ggab991fbe01cecb91bf18f4a403d7131a8a6b31d4db26762a30e5bb6a2f039cddc9" title="Some SASL mechanism requires realm value to be defined.">VORTEX_SASL_REALM</a>),
              <a class="code" href="group__vortex__sasl_gadd0de03529e7171917ed45c1ae375750.html#gadd0de03529e7171917ed45c1ae375750" title="Allows to get current SASL properties from the given connection.">vortex_sasl_get_propertie</a> (connection, <a class="code" href="group__vortex__sasl_gab991fbe01cecb91bf18f4a403d7131a8.html#ggab991fbe01cecb91bf18f4a403d7131a8a124fb5aa2dce6f95c61fd23d79e14955" title="Allows to configure anonymous token while using ANONYMOUS profile.">VORTEX_SASL_ANONYMOUS_TOKEN</a>));
 } <span class="keywordflow">else</span> {
     printf (<span class="stringliteral">&quot;Connection not authenticated..\n&quot;</span>);
     <span class="comment">// at this point DON&#39;T RELAY ON data returned by</span>
     <span class="comment">// - vortex_sasl_auth_method_used</span>
     <span class="comment">// - vortex_sasl_get_propertie </span>
 }
</pre></div> </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="lateral-ad">
  <iframe src="http://www.aspl.es/web-ads/index.php?hcolor=fdff4f&amp;fsize=10&amp;bg=555753&amp;fg=ffffff&amp;width=150&amp;type=vertical" height="420" align="middle" width="100%" scrolling="no" frameborder="0"></iframe>
</div>
<div class="footer">
<small>Vortex Library:  A BEEP (RFC3080/RFC3081) implementation. &nbsp; Copyright 2008 (C) Advanced Software Production Line, S.L.</small>
</div>
</body>
</html>

